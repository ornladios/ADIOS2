/* This file is generated from general.ops.  Do not edit directly. */

#include "../config.h"
#include "../cod.h"
#include "stdio.h"
#include <stdint.h>
#include "string.h"
#include "math.h"

#ifdef HAVE_WINDOWS_H
#include <windows.h>
#define srand48(s) srand(s)
#define drand48() (((double)rand())/((double)RAND_MAX))
#define lrand48() rand()
#define kill(x,y) 
#if defined(_MSC_VER)
#include <BaseTsd.h>
typedef SSIZE_T ssize_t;
#endif
#else
extern double drand48();
extern long lrand48();
void srand48(long seedval);
#endif

char* only_run_test = NULL;

static char extern_string[] = "int printf(string format, ...);";

static cod_extern_entry externs[2];

double src1d_vals[2];
double src2d_vals[2];
double br_srcd_vals[6];
signed char src1c_vals[3];
signed char src2c_vals[3];
signed char br_srcc_vals[6];
unsigned char src1uc_vals[3];
unsigned char src2uc_vals[3];
unsigned char br_srcuc_vals[6];
unsigned short src1us_vals[5];
unsigned short src2us_vals[5];
unsigned short br_srcus_vals[6];
float src1f_vals[2];
float src2f_vals[2];
float br_srcf_vals[6];
short src1s_vals[5];
short src2s_vals[5];
short br_srcs_vals[6];
intptr_t src1l_vals[9];
intptr_t src2l_vals[9];
intptr_t br_srcl_vals[6];
int src1i_vals[9];
int src2i_vals[9];
int br_srci_vals[6];
uintptr_t src1ul_vals[9];
uintptr_t src2ul_vals[9];
uintptr_t br_srcul_vals[6];
unsigned int src1u_vals[9];
unsigned int src2u_vals[9];
unsigned int br_srcu_vals[6];
char* src1p_vals[2];
char* src2p_vals[2];
char* br_srcp_vals[6];
int sh_src2_vals[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32};

int sh_src2s_vals[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16};

int sh_src2c_vals[] = { 0, 1, 2, 3, 4, 5, 6, 7, 8};

unsigned long bit_pattern_vals[] = { 0x1, 0x0,  0x2, 0x1,  0x4, 0x3,  0x8, 0x7,  0x10, 0xf,  0x20, 0x1f,  0x40, 0x3f,  0x80, 0x7f,  0x100, 0xff,  0x200, 0x1ff,  0x400, 0x3ff,  0x800, 0x7ff,  0x1000, 0xfff,  0x2000, 0x1fff,  0x4000, 0x3fff,  0x8000, 0x7fff,  0x10000, 0xffff,  0x20000, 0x1ffff,  0x40000, 0x3ffff,  0x80000, 0x7ffff,  0x100000, 0xfffff,  0x200000, 0x1fffff,  0x400000, 0x3fffff,  0x800000, 0x7fffff,  0x1000000, 0xffffff,  0x2000000, 0x1ffffff,  0x4000000, 0x3ffffff,  0x8000000, 0x7ffffff,  0x10000000, 0xfffffff,  0x20000000, 0x1fffffff,  0x40000000, 0x3fffffff,  0x80000000, 0x7fffffff,  0xffffffff};


int failed = 0;
int verbose = 0;

static void initialize_values()
{
    double rand1_d = (double)drand48();
    double rand2_d = (double)drand48();
    signed char rand1_c = (signed char)lrand48();
    signed char rand2_c = (signed char)lrand48();
    unsigned char rand1_uc = (unsigned char)lrand48();
    unsigned char rand2_uc = (unsigned char)lrand48();
    unsigned short rand1_us = (unsigned short)lrand48();
    unsigned short rand2_us = (unsigned short)lrand48();
    float rand1_f = (float)drand48();
    float rand2_f = (float)drand48();
    short rand1_s = (short)lrand48();
    short rand2_s = (short)lrand48();
    intptr_t rand1_l = (intptr_t)lrand48();
    intptr_t rand2_l = (intptr_t)lrand48();
    int rand1_i = (int)lrand48();
    int rand2_i = (int)lrand48();
    uintptr_t rand1_ul = (uintptr_t)lrand48();
    uintptr_t rand2_ul = (uintptr_t)lrand48();
    unsigned int rand1_u = (unsigned int)lrand48();
    unsigned int rand2_u = (unsigned int)lrand48();
    char* rand1_p = (char*)(intptr_t)lrand48();
    char* rand2_p = (char*)(intptr_t)lrand48();
    (void) rand1_p;
    (void) rand2_p;
    while (rand1_f == 0) rand1_f = (float)drand48();
    while (rand2_f == 0) rand2_f = (float)drand48();
    while (rand1_d == 0) rand1_d = (double)drand48();
    while (rand2_d == 0) rand2_d = (double)drand48();
    while (rand1_c == 0) rand1_c = (signed char)lrand48();
    while (rand2_c == 0) rand2_c = (signed char)lrand48();
    while (rand1_s == 0) rand1_s = (short)lrand48();
    while (rand2_s == 0) rand2_s = (short)lrand48();
    while (rand1_i == 0) rand1_i = (int)lrand48();
    while (rand2_i == 0) rand2_i = (int)lrand48();
    while (rand1_l == 0) rand1_l = (intptr_t)lrand48();
    while (rand2_l == 0) rand2_l = (intptr_t)lrand48();
    while (rand1_uc == 0) rand1_uc = (unsigned char)lrand48();
    while (rand2_uc == 0) rand2_uc = (unsigned char)lrand48();
    while (rand1_us == 0) rand1_us = (unsigned short)lrand48();
    while (rand2_us == 0) rand2_us = (unsigned short)lrand48();
    while (rand1_u == 0) rand1_u = (unsigned int)lrand48();
    while (rand2_u == 0) rand2_u = (unsigned int)lrand48();
    while (rand1_ul == 0) rand1_ul = (uintptr_t)lrand48();
    while (rand2_ul == 0) rand2_ul = (uintptr_t)lrand48();
    src1f_vals[0] = rand1_f;
    src1f_vals[1] = -rand1_f;
    src2f_vals[0] = rand2_f;
    src2f_vals[1] = -rand2_f;
    src1d_vals[0] = rand1_d;
    src1d_vals[1] = -rand1_d;
    src2d_vals[0] = rand2_d;
    src2d_vals[1] = -rand2_d;
    src1c_vals[0] = rand1_c;
    src1c_vals[1] = -rand1_c;
    src1c_vals[2] = rand1_c & 0xf;
    src2c_vals[0] = rand2_c;
    src2c_vals[1] = -rand2_c;
    src2c_vals[2] = rand2_c & 0xf;
    src1s_vals[0] = rand1_s;
    src1s_vals[1] = -rand1_s;
    src1s_vals[2] = rand1_s & 0xf;
    src1s_vals[3] = rand1_s & 0xff;
    src1s_vals[4] = rand1_s & 0xfff;
    src2s_vals[0] = rand2_s;
    src2s_vals[1] = -rand2_s;
    src2s_vals[2] = rand2_s & 0xf;
    src2s_vals[3] = rand2_s & 0xff;
    src2s_vals[4] = rand2_s & 0xfff;
    src1i_vals[0] = rand1_i;
    src1i_vals[1] = -rand1_i;
    src1i_vals[2] = rand1_i & 0xf;
    src1i_vals[3] = rand1_i & 0xff;
    src1i_vals[4] = rand1_i & 0xfff;
    src1i_vals[5] = rand1_i & 0xffff;
    src1i_vals[6] = rand1_i & 0xfffff;
    src1i_vals[7] = rand1_i & 0xffffff;
    src1i_vals[8] = rand1_i & 0xfffffff;
    src2i_vals[0] = rand2_i;
    src2i_vals[1] = -rand2_i;
    src2i_vals[2] = rand2_i & 0xf;
    src2i_vals[3] = rand2_i & 0xff;
    src2i_vals[4] = rand2_i & 0xfff;
    src2i_vals[5] = rand2_i & 0xffff;
    src2i_vals[6] = rand2_i & 0xfffff;
    src2i_vals[7] = rand2_i & 0xffffff;
    src2i_vals[8] = rand2_i & 0xfffffff;
    src1l_vals[0] = rand1_l;
    src1l_vals[1] = -rand1_l;
    src1l_vals[2] = rand1_l & 0xf;
    src1l_vals[3] = rand1_l & 0xff;
    src1l_vals[4] = rand1_l & 0xfff;
    src1l_vals[5] = rand1_l & 0xffff;
    src1l_vals[6] = rand1_l & 0xfffff;
    src1l_vals[7] = rand1_l & 0xffffff;
    src1l_vals[8] = rand1_l & 0xfffffff;
    src2l_vals[0] = rand2_l;
    src2l_vals[1] = -rand2_l;
    src2l_vals[2] = rand2_l & 0xf;
    src2l_vals[3] = rand2_l & 0xff;
    src2l_vals[4] = rand2_l & 0xfff;
    src2l_vals[5] = rand2_l & 0xffff;
    src2l_vals[6] = rand2_l & 0xfffff;
    src2l_vals[7] = rand2_l & 0xffffff;
    src2l_vals[8] = rand2_l & 0xfffffff;
    src1uc_vals[0] = (unsigned char) rand1_uc;
    src1uc_vals[1] = (unsigned char) -(long)rand1_uc;
    src1uc_vals[2] = (unsigned char)rand1_uc & 0xf;
    src2uc_vals[0] = (unsigned char) rand2_uc;
    src2uc_vals[1] = (unsigned char) -(long)rand2_uc;
    src2uc_vals[2] = (unsigned char)rand2_uc & 0xf;
    src1us_vals[0] = (unsigned short) rand1_us;
    src1us_vals[1] = (unsigned short) -(long)rand1_us;
    src1us_vals[2] = (unsigned short)rand1_us & 0xf;
    src1us_vals[3] = (unsigned short)rand1_us & 0xff;
    src1us_vals[4] = (unsigned short)rand1_us & 0xfff;
    src2us_vals[0] = (unsigned short) rand2_us;
    src2us_vals[1] = (unsigned short) -(long)rand2_us;
    src2us_vals[2] = (unsigned short)rand2_us & 0xf;
    src2us_vals[3] = (unsigned short)rand2_us & 0xff;
    src2us_vals[4] = (unsigned short)rand2_us & 0xfff;
    src1u_vals[0] = (unsigned int) rand1_u;
    src1u_vals[1] = (unsigned int) -(long)rand1_u;
    src1u_vals[2] = (unsigned int)rand1_u & 0xf;
    src1u_vals[3] = (unsigned int)rand1_u & 0xff;
    src1u_vals[4] = (unsigned int)rand1_u & 0xfff;
    src1u_vals[5] = (unsigned int)rand1_u & 0xffff;
    src1u_vals[6] = (unsigned int)rand1_u & 0xfffff;
    src1u_vals[7] = (unsigned int)rand1_u & 0xffffff;
    src1u_vals[8] = (unsigned int)rand1_u & 0xfffffff;
    src2u_vals[0] = (unsigned int) rand2_u;
    src2u_vals[1] = (unsigned int) -(long)rand2_u;
    src2u_vals[2] = (unsigned int)rand2_u & 0xf;
    src2u_vals[3] = (unsigned int)rand2_u & 0xff;
    src2u_vals[4] = (unsigned int)rand2_u & 0xfff;
    src2u_vals[5] = (unsigned int)rand2_u & 0xffff;
    src2u_vals[6] = (unsigned int)rand2_u & 0xfffff;
    src2u_vals[7] = (unsigned int)rand2_u & 0xffffff;
    src2u_vals[8] = (unsigned int)rand2_u & 0xfffffff;
    src1ul_vals[0] = (uintptr_t) rand1_ul;
    src1ul_vals[1] = (uintptr_t) -(long)rand1_ul;
    src1ul_vals[2] = (uintptr_t)rand1_ul & 0xf;
    src1ul_vals[3] = (uintptr_t)rand1_ul & 0xff;
    src1ul_vals[4] = (uintptr_t)rand1_ul & 0xfff;
    src1ul_vals[5] = (uintptr_t)rand1_ul & 0xffff;
    src1ul_vals[6] = (uintptr_t)rand1_ul & 0xfffff;
    src1ul_vals[7] = (uintptr_t)rand1_ul & 0xffffff;
    src1ul_vals[8] = (uintptr_t)rand1_ul & 0xfffffff;
    src2ul_vals[0] = (uintptr_t) rand2_ul;
    src2ul_vals[1] = (uintptr_t) -(long)rand2_ul;
    src2ul_vals[2] = (uintptr_t)rand2_ul & 0xf;
    src2ul_vals[3] = (uintptr_t)rand2_ul & 0xff;
    src2ul_vals[4] = (uintptr_t)rand2_ul & 0xfff;
    src2ul_vals[5] = (uintptr_t)rand2_ul & 0xffff;
    src2ul_vals[6] = (uintptr_t)rand2_ul & 0xfffff;
    src2ul_vals[7] = (uintptr_t)rand2_ul & 0xffffff;
    src2ul_vals[8] = (uintptr_t)rand2_ul & 0xfffffff;
    br_srcuc_vals[0] = (unsigned char) rand1_uc;
    br_srcuc_vals[1] = (unsigned char) (-(long)rand1_uc);
    br_srcuc_vals[2] = (unsigned char) rand1_uc + 1;
    br_srcuc_vals[3] = (unsigned char) (-(long)rand1_uc) + 1;
    br_srcuc_vals[4] = (unsigned char) rand1_uc - 1;
    br_srcuc_vals[5] = (unsigned char) -((long)rand1_uc) - 1;
    br_srcus_vals[0] = (unsigned short) rand1_us;
    br_srcus_vals[1] = (unsigned short) (-(long)rand1_us);
    br_srcus_vals[2] = (unsigned short) rand1_us + 1;
    br_srcus_vals[3] = (unsigned short) (-(long)rand1_us) + 1;
    br_srcus_vals[4] = (unsigned short) rand1_us - 1;
    br_srcus_vals[5] = (unsigned short) -((long)rand1_us) - 1;
    br_srcu_vals[0] = (unsigned int) rand1_u;
    br_srcu_vals[1] = (unsigned int) (-(long)rand1_u);
    br_srcu_vals[2] = (unsigned int) rand1_u + 1;
    br_srcu_vals[3] = (unsigned int) (-(long)rand1_u) + 1;
    br_srcu_vals[4] = (unsigned int) rand1_u - 1;
    br_srcu_vals[5] = (unsigned int) -((long)rand1_u) - 1;
    br_srcul_vals[0] = (uintptr_t) rand1_ul;
    br_srcul_vals[1] = (uintptr_t) (-(long)rand1_ul);
    br_srcul_vals[2] = (uintptr_t) rand1_ul + 1;
    br_srcul_vals[3] = (uintptr_t) (-(long)rand1_ul) + 1;
    br_srcul_vals[4] = (uintptr_t) rand1_ul - 1;
    br_srcul_vals[5] = (uintptr_t) -((long)rand1_ul) - 1;
    externs[0].extern_name = "printf";
    externs[0].extern_value = (void*)printf;
    externs[1].extern_name = (void*)0;
    externs[1].extern_value = (void*)0;
}
void mod_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % signed char */
    if (verbose) printf("test for signed char %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char %% signed char test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % unsigned char */
    if (verbose) printf("test for signed char %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip1;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char %% unsigned char test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip1: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % short */
    if (verbose) printf("test for signed char %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip2;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char %% short test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip2: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % unsigned short */
    if (verbose) printf("test for signed char %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip3;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char %% unsigned short test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip3: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % int */
    if (verbose) printf("test for signed char %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip4;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char %% int test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip4: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % unsigned int */
    if (verbose) printf("test for signed char %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip5;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char %% unsigned int test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip5: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % uintptr_t */
    if (verbose) printf("test for signed char %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip6;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char %% uintptr_t test, expected %d, got %d, for %d %% %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip6: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char % intptr_t */
    if (verbose) printf("test for signed char %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip7;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c % source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char %% intptr_t test, expected %d, got %d, for %d %% %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip7: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % signed char */
    if (verbose) printf("test for unsigned char %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip8;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% signed char test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip8: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % unsigned char */
    if (verbose) printf("test for unsigned char %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip9;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% unsigned char test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip9: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % short */
    if (verbose) printf("test for unsigned char %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip10;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% short test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip10: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % unsigned short */
    if (verbose) printf("test for unsigned char %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip11;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% unsigned short test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip11: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % int */
    if (verbose) printf("test for unsigned char %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip12;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% int test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip12: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % unsigned int */
    if (verbose) printf("test for unsigned char %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip13;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% unsigned int test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip13: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % uintptr_t */
    if (verbose) printf("test for unsigned char %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip14;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% uintptr_t test, expected %u, got %u, for %u %% %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip14: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char % intptr_t */
    if (verbose) printf("test for unsigned char %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip15;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc % source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char %% intptr_t test, expected %u, got %u, for %u %% %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip15: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % signed char */
    if (verbose) printf("test for short %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip16;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short %% signed char test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip16: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % unsigned char */
    if (verbose) printf("test for short %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip17;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short %% unsigned char test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip17: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % short */
    if (verbose) printf("test for short %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip18;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short %% short test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip18: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % unsigned short */
    if (verbose) printf("test for short %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip19;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short %% unsigned short test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip19: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % int */
    if (verbose) printf("test for short %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip20;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short %% int test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip20: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % unsigned int */
    if (verbose) printf("test for short %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip21;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short %% unsigned int test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip21: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % uintptr_t */
    if (verbose) printf("test for short %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip22;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short %% uintptr_t test, expected %d, got %d, for %d %% %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip22: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short % intptr_t */
    if (verbose) printf("test for short %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip23;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s % source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short %% intptr_t test, expected %d, got %d, for %d %% %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip23: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % signed char */
    if (verbose) printf("test for unsigned short %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip24;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% signed char test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip24: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % unsigned char */
    if (verbose) printf("test for unsigned short %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip25;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% unsigned char test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip25: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % short */
    if (verbose) printf("test for unsigned short %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip26;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% short test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip26: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % unsigned short */
    if (verbose) printf("test for unsigned short %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip27;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% unsigned short test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip27: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % int */
    if (verbose) printf("test for unsigned short %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip28;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% int test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip28: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % unsigned int */
    if (verbose) printf("test for unsigned short %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip29;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% unsigned int test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip29: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % uintptr_t */
    if (verbose) printf("test for unsigned short %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip30;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% uintptr_t test, expected %u, got %u, for %u %% %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip30: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short % intptr_t */
    if (verbose) printf("test for unsigned short %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip31;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us % source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short %% intptr_t test, expected %u, got %u, for %u %% %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip31: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % signed char */
    if (verbose) printf("test for int %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip32;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int %% signed char test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip32: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % unsigned char */
    if (verbose) printf("test for int %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip33;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int %% unsigned char test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip33: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % short */
    if (verbose) printf("test for int %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip34;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int %% short test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip34: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % unsigned short */
    if (verbose) printf("test for int %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip35;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int %% unsigned short test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip35: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % int */
    if (verbose) printf("test for int %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip36;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int %% int test, expected %d, got %d, for %d %% %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip36: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % unsigned int */
    if (verbose) printf("test for int %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip37;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int %% unsigned int test, expected %d, got %d, for %d %% %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip37: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % uintptr_t */
    if (verbose) printf("test for int %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip38;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int %% uintptr_t test, expected %d, got %d, for %d %% %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip38: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int % intptr_t */
    if (verbose) printf("test for int %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip39;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i % source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int %% intptr_t test, expected %d, got %d, for %d %% %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip39: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % signed char */
    if (verbose) printf("test for unsigned int %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip40;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% signed char test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip40: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % unsigned char */
    if (verbose) printf("test for unsigned int %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip41;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% unsigned char test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip41: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % short */
    if (verbose) printf("test for unsigned int %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip42;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% short test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip42: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % unsigned short */
    if (verbose) printf("test for unsigned int %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip43;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% unsigned short test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip43: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % int */
    if (verbose) printf("test for unsigned int %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip44;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% int test, expected %u, got %u, for %u %% %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip44: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % unsigned int */
    if (verbose) printf("test for unsigned int %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip45;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% unsigned int test, expected %u, got %u, for %u %% %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip45: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % uintptr_t */
    if (verbose) printf("test for unsigned int %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip46;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% uintptr_t test, expected %u, got %u, for %u %% %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip46: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int % intptr_t */
    if (verbose) printf("test for unsigned int %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip47;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u % source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int %% intptr_t test, expected %u, got %u, for %u %% %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip47: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % signed char */
    if (verbose) printf("test for uintptr_t %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip48;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% signed char test, expected %zu, got %zu, for %zu %% %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip48: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % unsigned char */
    if (verbose) printf("test for uintptr_t %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip49;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% unsigned char test, expected %zu, got %zu, for %zu %% %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip49: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % short */
    if (verbose) printf("test for uintptr_t %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip50;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% short test, expected %zu, got %zu, for %zu %% %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip50: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % unsigned short */
    if (verbose) printf("test for uintptr_t %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip51;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% unsigned short test, expected %zu, got %zu, for %zu %% %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip51: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % int */
    if (verbose) printf("test for uintptr_t %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip52;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% int test, expected %zu, got %zu, for %zu %% %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip52: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % unsigned int */
    if (verbose) printf("test for uintptr_t %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip53;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% unsigned int test, expected %zu, got %zu, for %zu %% %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip53: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % uintptr_t */
    if (verbose) printf("test for uintptr_t %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip54;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% uintptr_t test, expected %zu, got %zu, for %zu %% %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip54: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t % intptr_t */
    if (verbose) printf("test for uintptr_t %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip55;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul % source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t %% intptr_t test, expected %zu, got %zu, for %zu %% %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip55: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mod_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % signed char */
    if (verbose) printf("test for intptr_t %% signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_c <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip56;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t %% signed char test, expected %zd, got %zd, for %zd %% %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip56: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % unsigned char */
    if (verbose) printf("test for intptr_t %% unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_uc <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip57;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t %% unsigned char test, expected %zd, got %zd, for %zd %% %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip57: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % short */
    if (verbose) printf("test for intptr_t %% short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_s <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip58;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t %% short test, expected %zd, got %zd, for %zd %% %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip58: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % unsigned short */
    if (verbose) printf("test for intptr_t %% unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_us <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip59;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t %% unsigned short test, expected %zd, got %zd, for %zd %% %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip59: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % int */
    if (verbose) printf("test for intptr_t %% int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_i <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip60;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t %% int test, expected %zd, got %zd, for %zd %% %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip60: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % unsigned int */
    if (verbose) printf("test for intptr_t %% unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_u <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip61;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t %% unsigned int test, expected %zd, got %zd, for %zd %% %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip61: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % uintptr_t */
    if (verbose) printf("test for intptr_t %% uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_ul <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip62;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t %% uintptr_t test, expected %zd, got %zd, for %zd %% %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip62: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l%l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a % b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t % intptr_t */
    if (verbose) printf("test for intptr_t %% intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_l <= 0) {if (verbose) {printf("+");fflush(stdout);} goto skip63;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l % source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t %% intptr_t test, expected %zd, got %zd, for %zd %% %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip63: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & signed char */
    if (verbose) printf("test for signed char & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char & signed char test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & unsigned char */
    if (verbose) printf("test for signed char & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char & unsigned char test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & short */
    if (verbose) printf("test for signed char & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char & short test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & unsigned short */
    if (verbose) printf("test for signed char & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char & unsigned short test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & int */
    if (verbose) printf("test for signed char & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char & int test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & unsigned int */
    if (verbose) printf("test for signed char & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char & unsigned int test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & uintptr_t */
    if (verbose) printf("test for signed char & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char & uintptr_t test, expected %d, got %d, for %d & %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char & intptr_t */
    if (verbose) printf("test for signed char & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c & source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char & intptr_t test, expected %d, got %d, for %d & %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & signed char */
    if (verbose) printf("test for unsigned char & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & signed char test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & unsigned char */
    if (verbose) printf("test for unsigned char & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & unsigned char test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & short */
    if (verbose) printf("test for unsigned char & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & short test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & unsigned short */
    if (verbose) printf("test for unsigned char & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & unsigned short test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & int */
    if (verbose) printf("test for unsigned char & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & int test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & unsigned int */
    if (verbose) printf("test for unsigned char & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & unsigned int test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & uintptr_t */
    if (verbose) printf("test for unsigned char & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & uintptr_t test, expected %u, got %u, for %u & %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char & intptr_t */
    if (verbose) printf("test for unsigned char & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc & source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char & intptr_t test, expected %u, got %u, for %u & %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & signed char */
    if (verbose) printf("test for short & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short & signed char test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & unsigned char */
    if (verbose) printf("test for short & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short & unsigned char test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & short */
    if (verbose) printf("test for short & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short & short test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & unsigned short */
    if (verbose) printf("test for short & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short & unsigned short test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & int */
    if (verbose) printf("test for short & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short & int test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & unsigned int */
    if (verbose) printf("test for short & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short & unsigned int test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & uintptr_t */
    if (verbose) printf("test for short & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short & uintptr_t test, expected %d, got %d, for %d & %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short & intptr_t */
    if (verbose) printf("test for short & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s & source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short & intptr_t test, expected %d, got %d, for %d & %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & signed char */
    if (verbose) printf("test for unsigned short & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & signed char test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & unsigned char */
    if (verbose) printf("test for unsigned short & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & unsigned char test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & short */
    if (verbose) printf("test for unsigned short & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & short test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & unsigned short */
    if (verbose) printf("test for unsigned short & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & unsigned short test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & int */
    if (verbose) printf("test for unsigned short & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & int test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & unsigned int */
    if (verbose) printf("test for unsigned short & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & unsigned int test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & uintptr_t */
    if (verbose) printf("test for unsigned short & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & uintptr_t test, expected %u, got %u, for %u & %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short & intptr_t */
    if (verbose) printf("test for unsigned short & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us & source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short & intptr_t test, expected %u, got %u, for %u & %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & signed char */
    if (verbose) printf("test for int & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int & signed char test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & unsigned char */
    if (verbose) printf("test for int & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int & unsigned char test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & short */
    if (verbose) printf("test for int & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int & short test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & unsigned short */
    if (verbose) printf("test for int & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int & unsigned short test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & int */
    if (verbose) printf("test for int & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int & int test, expected %d, got %d, for %d & %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & unsigned int */
    if (verbose) printf("test for int & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int & unsigned int test, expected %d, got %d, for %d & %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & uintptr_t */
    if (verbose) printf("test for int & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int & uintptr_t test, expected %d, got %d, for %d & %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int & intptr_t */
    if (verbose) printf("test for int & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i & source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int & intptr_t test, expected %d, got %d, for %d & %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & signed char */
    if (verbose) printf("test for unsigned int & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & signed char test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & unsigned char */
    if (verbose) printf("test for unsigned int & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & unsigned char test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & short */
    if (verbose) printf("test for unsigned int & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & short test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & unsigned short */
    if (verbose) printf("test for unsigned int & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & unsigned short test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & int */
    if (verbose) printf("test for unsigned int & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & int test, expected %u, got %u, for %u & %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & unsigned int */
    if (verbose) printf("test for unsigned int & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & unsigned int test, expected %u, got %u, for %u & %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & uintptr_t */
    if (verbose) printf("test for unsigned int & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & uintptr_t test, expected %u, got %u, for %u & %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int & intptr_t */
    if (verbose) printf("test for unsigned int & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u & source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int & intptr_t test, expected %u, got %u, for %u & %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & signed char */
    if (verbose) printf("test for uintptr_t & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & signed char test, expected %zu, got %zu, for %zu & %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & unsigned char */
    if (verbose) printf("test for uintptr_t & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & unsigned char test, expected %zu, got %zu, for %zu & %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & short */
    if (verbose) printf("test for uintptr_t & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & short test, expected %zu, got %zu, for %zu & %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & unsigned short */
    if (verbose) printf("test for uintptr_t & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & unsigned short test, expected %zu, got %zu, for %zu & %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & int */
    if (verbose) printf("test for uintptr_t & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & int test, expected %zu, got %zu, for %zu & %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & unsigned int */
    if (verbose) printf("test for uintptr_t & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & unsigned int test, expected %zu, got %zu, for %zu & %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & uintptr_t */
    if (verbose) printf("test for uintptr_t & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & uintptr_t test, expected %zu, got %zu, for %zu & %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t & intptr_t */
    if (verbose) printf("test for uintptr_t & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul & source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t & intptr_t test, expected %zu, got %zu, for %zu & %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void and_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & signed char */
    if (verbose) printf("test for intptr_t & signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t & signed char test, expected %zd, got %zd, for %zd & %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & unsigned char */
    if (verbose) printf("test for intptr_t & unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t & unsigned char test, expected %zd, got %zd, for %zd & %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & short */
    if (verbose) printf("test for intptr_t & short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t & short test, expected %zd, got %zd, for %zd & %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & unsigned short */
    if (verbose) printf("test for intptr_t & unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t & unsigned short test, expected %zd, got %zd, for %zd & %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & int */
    if (verbose) printf("test for intptr_t & int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t & int test, expected %zd, got %zd, for %zd & %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & unsigned int */
    if (verbose) printf("test for intptr_t & unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t & unsigned int test, expected %zd, got %zd, for %zd & %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & uintptr_t */
    if (verbose) printf("test for intptr_t & uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t & uintptr_t test, expected %zd, got %zd, for %zd & %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l&l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a & b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t & intptr_t */
    if (verbose) printf("test for intptr_t & intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l & source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t & intptr_t test, expected %zd, got %zd, for %zd & %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | signed char */
    if (verbose) printf("test for signed char | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char | signed char test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | unsigned char */
    if (verbose) printf("test for signed char | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char | unsigned char test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | short */
    if (verbose) printf("test for signed char | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char | short test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | unsigned short */
    if (verbose) printf("test for signed char | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char | unsigned short test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | int */
    if (verbose) printf("test for signed char | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char | int test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | unsigned int */
    if (verbose) printf("test for signed char | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char | unsigned int test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | uintptr_t */
    if (verbose) printf("test for signed char | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char | uintptr_t test, expected %d, got %d, for %d | %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char | intptr_t */
    if (verbose) printf("test for signed char | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c | source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char | intptr_t test, expected %d, got %d, for %d | %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | signed char */
    if (verbose) printf("test for unsigned char | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | signed char test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | unsigned char */
    if (verbose) printf("test for unsigned char | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | unsigned char test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | short */
    if (verbose) printf("test for unsigned char | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | short test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | unsigned short */
    if (verbose) printf("test for unsigned char | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | unsigned short test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | int */
    if (verbose) printf("test for unsigned char | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | int test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | unsigned int */
    if (verbose) printf("test for unsigned char | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | unsigned int test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | uintptr_t */
    if (verbose) printf("test for unsigned char | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | uintptr_t test, expected %u, got %u, for %u | %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char | intptr_t */
    if (verbose) printf("test for unsigned char | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc | source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char | intptr_t test, expected %u, got %u, for %u | %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | signed char */
    if (verbose) printf("test for short | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short | signed char test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | unsigned char */
    if (verbose) printf("test for short | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short | unsigned char test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | short */
    if (verbose) printf("test for short | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short | short test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | unsigned short */
    if (verbose) printf("test for short | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short | unsigned short test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | int */
    if (verbose) printf("test for short | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short | int test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | unsigned int */
    if (verbose) printf("test for short | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short | unsigned int test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | uintptr_t */
    if (verbose) printf("test for short | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short | uintptr_t test, expected %d, got %d, for %d | %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short | intptr_t */
    if (verbose) printf("test for short | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s | source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short | intptr_t test, expected %d, got %d, for %d | %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | signed char */
    if (verbose) printf("test for unsigned short | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | signed char test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | unsigned char */
    if (verbose) printf("test for unsigned short | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | unsigned char test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | short */
    if (verbose) printf("test for unsigned short | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | short test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | unsigned short */
    if (verbose) printf("test for unsigned short | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | unsigned short test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | int */
    if (verbose) printf("test for unsigned short | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | int test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | unsigned int */
    if (verbose) printf("test for unsigned short | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | unsigned int test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | uintptr_t */
    if (verbose) printf("test for unsigned short | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | uintptr_t test, expected %u, got %u, for %u | %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short | intptr_t */
    if (verbose) printf("test for unsigned short | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us | source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short | intptr_t test, expected %u, got %u, for %u | %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | signed char */
    if (verbose) printf("test for int | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int | signed char test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | unsigned char */
    if (verbose) printf("test for int | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int | unsigned char test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | short */
    if (verbose) printf("test for int | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int | short test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | unsigned short */
    if (verbose) printf("test for int | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int | unsigned short test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | int */
    if (verbose) printf("test for int | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int | int test, expected %d, got %d, for %d | %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | unsigned int */
    if (verbose) printf("test for int | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int | unsigned int test, expected %d, got %d, for %d | %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | uintptr_t */
    if (verbose) printf("test for int | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int | uintptr_t test, expected %d, got %d, for %d | %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int | intptr_t */
    if (verbose) printf("test for int | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i | source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int | intptr_t test, expected %d, got %d, for %d | %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | signed char */
    if (verbose) printf("test for unsigned int | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | signed char test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | unsigned char */
    if (verbose) printf("test for unsigned int | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | unsigned char test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | short */
    if (verbose) printf("test for unsigned int | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | short test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | unsigned short */
    if (verbose) printf("test for unsigned int | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | unsigned short test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | int */
    if (verbose) printf("test for unsigned int | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | int test, expected %u, got %u, for %u | %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | unsigned int */
    if (verbose) printf("test for unsigned int | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | unsigned int test, expected %u, got %u, for %u | %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | uintptr_t */
    if (verbose) printf("test for unsigned int | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | uintptr_t test, expected %u, got %u, for %u | %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int | intptr_t */
    if (verbose) printf("test for unsigned int | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u | source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int | intptr_t test, expected %u, got %u, for %u | %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | signed char */
    if (verbose) printf("test for uintptr_t | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | signed char test, expected %zu, got %zu, for %zu | %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | unsigned char */
    if (verbose) printf("test for uintptr_t | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | unsigned char test, expected %zu, got %zu, for %zu | %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | short */
    if (verbose) printf("test for uintptr_t | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | short test, expected %zu, got %zu, for %zu | %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | unsigned short */
    if (verbose) printf("test for uintptr_t | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | unsigned short test, expected %zu, got %zu, for %zu | %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | int */
    if (verbose) printf("test for uintptr_t | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | int test, expected %zu, got %zu, for %zu | %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | unsigned int */
    if (verbose) printf("test for uintptr_t | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | unsigned int test, expected %zu, got %zu, for %zu | %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | uintptr_t */
    if (verbose) printf("test for uintptr_t | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | uintptr_t test, expected %zu, got %zu, for %zu | %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t | intptr_t */
    if (verbose) printf("test for uintptr_t | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul | source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t | intptr_t test, expected %zu, got %zu, for %zu | %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void or_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | signed char */
    if (verbose) printf("test for intptr_t | signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t | signed char test, expected %zd, got %zd, for %zd | %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | unsigned char */
    if (verbose) printf("test for intptr_t | unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t | unsigned char test, expected %zd, got %zd, for %zd | %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | short */
    if (verbose) printf("test for intptr_t | short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t | short test, expected %zd, got %zd, for %zd | %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | unsigned short */
    if (verbose) printf("test for intptr_t | unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t | unsigned short test, expected %zd, got %zd, for %zd | %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | int */
    if (verbose) printf("test for intptr_t | int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t | int test, expected %zd, got %zd, for %zd | %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | unsigned int */
    if (verbose) printf("test for intptr_t | unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t | unsigned int test, expected %zd, got %zd, for %zd | %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | uintptr_t */
    if (verbose) printf("test for intptr_t | uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t | uintptr_t test, expected %zd, got %zd, for %zd | %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l|l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a | b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t | intptr_t */
    if (verbose) printf("test for intptr_t | intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l | source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t | intptr_t test, expected %zd, got %zd, for %zd | %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ signed char */
    if (verbose) printf("test for signed char ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char ^ signed char test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ unsigned char */
    if (verbose) printf("test for signed char ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char ^ unsigned char test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ short */
    if (verbose) printf("test for signed char ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char ^ short test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ unsigned short */
    if (verbose) printf("test for signed char ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char ^ unsigned short test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ int */
    if (verbose) printf("test for signed char ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char ^ int test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ unsigned int */
    if (verbose) printf("test for signed char ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char ^ unsigned int test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ uintptr_t */
    if (verbose) printf("test for signed char ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char ^ uintptr_t test, expected %d, got %d, for %d ^ %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char ^ intptr_t */
    if (verbose) printf("test for signed char ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c ^ source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char ^ intptr_t test, expected %d, got %d, for %d ^ %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ signed char */
    if (verbose) printf("test for unsigned char ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ signed char test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ unsigned char */
    if (verbose) printf("test for unsigned char ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ unsigned char test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ short */
    if (verbose) printf("test for unsigned char ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ short test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ unsigned short */
    if (verbose) printf("test for unsigned char ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ unsigned short test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ int */
    if (verbose) printf("test for unsigned char ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ int test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ unsigned int */
    if (verbose) printf("test for unsigned char ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ unsigned int test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ uintptr_t */
    if (verbose) printf("test for unsigned char ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ uintptr_t test, expected %u, got %u, for %u ^ %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char ^ intptr_t */
    if (verbose) printf("test for unsigned char ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc ^ source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char ^ intptr_t test, expected %u, got %u, for %u ^ %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ signed char */
    if (verbose) printf("test for short ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short ^ signed char test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ unsigned char */
    if (verbose) printf("test for short ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short ^ unsigned char test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ short */
    if (verbose) printf("test for short ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short ^ short test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ unsigned short */
    if (verbose) printf("test for short ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short ^ unsigned short test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ int */
    if (verbose) printf("test for short ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short ^ int test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ unsigned int */
    if (verbose) printf("test for short ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short ^ unsigned int test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ uintptr_t */
    if (verbose) printf("test for short ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short ^ uintptr_t test, expected %d, got %d, for %d ^ %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short ^ intptr_t */
    if (verbose) printf("test for short ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s ^ source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short ^ intptr_t test, expected %d, got %d, for %d ^ %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ signed char */
    if (verbose) printf("test for unsigned short ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ signed char test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ unsigned char */
    if (verbose) printf("test for unsigned short ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ unsigned char test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ short */
    if (verbose) printf("test for unsigned short ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ short test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ unsigned short */
    if (verbose) printf("test for unsigned short ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ unsigned short test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ int */
    if (verbose) printf("test for unsigned short ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ int test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ unsigned int */
    if (verbose) printf("test for unsigned short ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ unsigned int test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ uintptr_t */
    if (verbose) printf("test for unsigned short ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ uintptr_t test, expected %u, got %u, for %u ^ %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short ^ intptr_t */
    if (verbose) printf("test for unsigned short ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us ^ source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short ^ intptr_t test, expected %u, got %u, for %u ^ %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ signed char */
    if (verbose) printf("test for int ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int ^ signed char test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ unsigned char */
    if (verbose) printf("test for int ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int ^ unsigned char test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ short */
    if (verbose) printf("test for int ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int ^ short test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ unsigned short */
    if (verbose) printf("test for int ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int ^ unsigned short test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ int */
    if (verbose) printf("test for int ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int ^ int test, expected %d, got %d, for %d ^ %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ unsigned int */
    if (verbose) printf("test for int ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int ^ unsigned int test, expected %d, got %d, for %d ^ %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ uintptr_t */
    if (verbose) printf("test for int ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int ^ uintptr_t test, expected %d, got %d, for %d ^ %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int ^ intptr_t */
    if (verbose) printf("test for int ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i ^ source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int ^ intptr_t test, expected %d, got %d, for %d ^ %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ signed char */
    if (verbose) printf("test for unsigned int ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ signed char test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ unsigned char */
    if (verbose) printf("test for unsigned int ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ unsigned char test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ short */
    if (verbose) printf("test for unsigned int ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ short test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ unsigned short */
    if (verbose) printf("test for unsigned int ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ unsigned short test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ int */
    if (verbose) printf("test for unsigned int ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ int test, expected %u, got %u, for %u ^ %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ unsigned int */
    if (verbose) printf("test for unsigned int ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ unsigned int test, expected %u, got %u, for %u ^ %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ uintptr_t */
    if (verbose) printf("test for unsigned int ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ uintptr_t test, expected %u, got %u, for %u ^ %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int ^ intptr_t */
    if (verbose) printf("test for unsigned int ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u ^ source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int ^ intptr_t test, expected %u, got %u, for %u ^ %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ signed char */
    if (verbose) printf("test for uintptr_t ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ signed char test, expected %zu, got %zu, for %zu ^ %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ unsigned char */
    if (verbose) printf("test for uintptr_t ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ unsigned char test, expected %zu, got %zu, for %zu ^ %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ short */
    if (verbose) printf("test for uintptr_t ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ short test, expected %zu, got %zu, for %zu ^ %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ unsigned short */
    if (verbose) printf("test for uintptr_t ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ unsigned short test, expected %zu, got %zu, for %zu ^ %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ int */
    if (verbose) printf("test for uintptr_t ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ int test, expected %zu, got %zu, for %zu ^ %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ unsigned int */
    if (verbose) printf("test for uintptr_t ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ unsigned int test, expected %zu, got %zu, for %zu ^ %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ uintptr_t */
    if (verbose) printf("test for uintptr_t ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ uintptr_t test, expected %zu, got %zu, for %zu ^ %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t ^ intptr_t */
    if (verbose) printf("test for uintptr_t ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul ^ source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t ^ intptr_t test, expected %zu, got %zu, for %zu ^ %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void not_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ signed char */
    if (verbose) printf("test for intptr_t ^ signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ signed char test, expected %zd, got %zd, for %zd ^ %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ unsigned char */
    if (verbose) printf("test for intptr_t ^ unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ unsigned char test, expected %zd, got %zd, for %zd ^ %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ short */
    if (verbose) printf("test for intptr_t ^ short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ short test, expected %zd, got %zd, for %zd ^ %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ unsigned short */
    if (verbose) printf("test for intptr_t ^ unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ unsigned short test, expected %zd, got %zd, for %zd ^ %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ int */
    if (verbose) printf("test for intptr_t ^ int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ int test, expected %zd, got %zd, for %zd ^ %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ unsigned int */
    if (verbose) printf("test for intptr_t ^ unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ unsigned int test, expected %zd, got %zd, for %zd ^ %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ uintptr_t */
    if (verbose) printf("test for intptr_t ^ uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ uintptr_t test, expected %zd, got %zd, for %zd ^ %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l^l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a ^ b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t ^ intptr_t */
    if (verbose) printf("test for intptr_t ^ intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l ^ source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t ^ intptr_t test, expected %zd, got %zd, for %zd ^ %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << signed char */
    if (verbose) printf("test for signed char << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char << signed char test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << unsigned char */
    if (verbose) printf("test for signed char << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char << unsigned char test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << short */
    if (verbose) printf("test for signed char << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char << short test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << unsigned short */
    if (verbose) printf("test for signed char << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char << unsigned short test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << int */
    if (verbose) printf("test for signed char << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char << int test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << unsigned int */
    if (verbose) printf("test for signed char << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char << unsigned int test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << uintptr_t */
    if (verbose) printf("test for signed char << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char << uintptr_t test, expected %d, got %d, for %d << %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char << intptr_t */
    if (verbose) printf("test for signed char << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c << source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char << intptr_t test, expected %d, got %d, for %d << %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << signed char */
    if (verbose) printf("test for unsigned char << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << signed char test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << unsigned char */
    if (verbose) printf("test for unsigned char << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << unsigned char test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << short */
    if (verbose) printf("test for unsigned char << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << short test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << unsigned short */
    if (verbose) printf("test for unsigned char << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << unsigned short test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << int */
    if (verbose) printf("test for unsigned char << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << int test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << unsigned int */
    if (verbose) printf("test for unsigned char << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << unsigned int test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << uintptr_t */
    if (verbose) printf("test for unsigned char << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << uintptr_t test, expected %u, got %u, for %u << %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char << intptr_t */
    if (verbose) printf("test for unsigned char << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc << source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char << intptr_t test, expected %u, got %u, for %u << %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << signed char */
    if (verbose) printf("test for short << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short << signed char test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << unsigned char */
    if (verbose) printf("test for short << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short << unsigned char test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << short */
    if (verbose) printf("test for short << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short << short test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << unsigned short */
    if (verbose) printf("test for short << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short << unsigned short test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << int */
    if (verbose) printf("test for short << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short << int test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << unsigned int */
    if (verbose) printf("test for short << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short << unsigned int test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << uintptr_t */
    if (verbose) printf("test for short << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short << uintptr_t test, expected %d, got %d, for %d << %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short << intptr_t */
    if (verbose) printf("test for short << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s << source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short << intptr_t test, expected %d, got %d, for %d << %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << signed char */
    if (verbose) printf("test for unsigned short << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << signed char test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << unsigned char */
    if (verbose) printf("test for unsigned short << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << unsigned char test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << short */
    if (verbose) printf("test for unsigned short << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << short test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << unsigned short */
    if (verbose) printf("test for unsigned short << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << unsigned short test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << int */
    if (verbose) printf("test for unsigned short << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << int test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << unsigned int */
    if (verbose) printf("test for unsigned short << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << unsigned int test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << uintptr_t */
    if (verbose) printf("test for unsigned short << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << uintptr_t test, expected %u, got %u, for %u << %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short << intptr_t */
    if (verbose) printf("test for unsigned short << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us << source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short << intptr_t test, expected %u, got %u, for %u << %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << signed char */
    if (verbose) printf("test for int << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int << signed char test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << unsigned char */
    if (verbose) printf("test for int << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int << unsigned char test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << short */
    if (verbose) printf("test for int << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int << short test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << unsigned short */
    if (verbose) printf("test for int << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int << unsigned short test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << int */
    if (verbose) printf("test for int << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int << int test, expected %d, got %d, for %d << %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << unsigned int */
    if (verbose) printf("test for int << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int << unsigned int test, expected %d, got %d, for %d << %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << uintptr_t */
    if (verbose) printf("test for int << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int << uintptr_t test, expected %d, got %d, for %d << %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int << intptr_t */
    if (verbose) printf("test for int << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i << source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int << intptr_t test, expected %d, got %d, for %d << %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << signed char */
    if (verbose) printf("test for unsigned int << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << signed char test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << unsigned char */
    if (verbose) printf("test for unsigned int << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << unsigned char test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << short */
    if (verbose) printf("test for unsigned int << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << short test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << unsigned short */
    if (verbose) printf("test for unsigned int << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << unsigned short test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << int */
    if (verbose) printf("test for unsigned int << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << int test, expected %u, got %u, for %u << %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << unsigned int */
    if (verbose) printf("test for unsigned int << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << unsigned int test, expected %u, got %u, for %u << %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << uintptr_t */
    if (verbose) printf("test for unsigned int << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << uintptr_t test, expected %u, got %u, for %u << %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int << intptr_t */
    if (verbose) printf("test for unsigned int << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u << source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int << intptr_t test, expected %u, got %u, for %u << %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << signed char */
    if (verbose) printf("test for uintptr_t << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << signed char test, expected %zu, got %zu, for %zu << %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << unsigned char */
    if (verbose) printf("test for uintptr_t << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << unsigned char test, expected %zu, got %zu, for %zu << %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << short */
    if (verbose) printf("test for uintptr_t << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << short test, expected %zu, got %zu, for %zu << %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << unsigned short */
    if (verbose) printf("test for uintptr_t << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << unsigned short test, expected %zu, got %zu, for %zu << %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << int */
    if (verbose) printf("test for uintptr_t << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << int test, expected %zu, got %zu, for %zu << %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << unsigned int */
    if (verbose) printf("test for uintptr_t << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << unsigned int test, expected %zu, got %zu, for %zu << %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << uintptr_t */
    if (verbose) printf("test for uintptr_t << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << uintptr_t test, expected %zu, got %zu, for %zu << %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t << intptr_t */
    if (verbose) printf("test for uintptr_t << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul << source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t << intptr_t test, expected %zu, got %zu, for %zu << %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void lsh_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << signed char */
    if (verbose) printf("test for intptr_t << signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t << signed char test, expected %zd, got %zd, for %zd << %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << unsigned char */
    if (verbose) printf("test for intptr_t << unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t << unsigned char test, expected %zd, got %zd, for %zd << %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << short */
    if (verbose) printf("test for intptr_t << short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t << short test, expected %zd, got %zd, for %zd << %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << unsigned short */
    if (verbose) printf("test for intptr_t << unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t << unsigned short test, expected %zd, got %zd, for %zd << %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << int */
    if (verbose) printf("test for intptr_t << int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t << int test, expected %zd, got %zd, for %zd << %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << unsigned int */
    if (verbose) printf("test for intptr_t << unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t << unsigned int test, expected %zd, got %zd, for %zd << %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << uintptr_t */
    if (verbose) printf("test for intptr_t << uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t << uintptr_t test, expected %zd, got %zd, for %zd << %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l<<l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a << b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t << intptr_t */
    if (verbose) printf("test for intptr_t << intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l << source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t << intptr_t test, expected %zd, got %zd, for %zd << %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> signed char */
    if (verbose) printf("test for signed char >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_c >= sizeof(source1_c)) goto skip64;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char >> signed char test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip64: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> unsigned char */
    if (verbose) printf("test for signed char >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_uc >= sizeof(source1_c)) goto skip65;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char >> unsigned char test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip65: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> short */
    if (verbose) printf("test for signed char >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_s >= sizeof(source1_c)) goto skip66;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char >> short test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip66: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> unsigned short */
    if (verbose) printf("test for signed char >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_us >= sizeof(source1_c)) goto skip67;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char >> unsigned short test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip67: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> int */
    if (verbose) printf("test for signed char >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_i >= sizeof(source1_c)) goto skip68;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char >> int test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip68: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> unsigned int */
    if (verbose) printf("test for signed char >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_u >= sizeof(source1_c)) goto skip69;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char >> unsigned int test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip69: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> uintptr_t */
    if (verbose) printf("test for signed char >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_ul >= sizeof(source1_c)) goto skip70;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char >> uintptr_t test, expected %d, got %d, for %d >> %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip70: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char >> intptr_t */
    if (verbose) printf("test for signed char >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_l >= sizeof(source1_c)) goto skip71;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c >> source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char >> intptr_t test, expected %d, got %d, for %d >> %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip71: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> signed char */
    if (verbose) printf("test for unsigned char >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_c >= sizeof(source1_uc)) goto skip72;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> signed char test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip72: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> unsigned char */
    if (verbose) printf("test for unsigned char >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_uc >= sizeof(source1_uc)) goto skip73;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> unsigned char test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip73: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> short */
    if (verbose) printf("test for unsigned char >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_s >= sizeof(source1_uc)) goto skip74;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> short test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip74: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> unsigned short */
    if (verbose) printf("test for unsigned char >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_us >= sizeof(source1_uc)) goto skip75;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> unsigned short test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip75: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> int */
    if (verbose) printf("test for unsigned char >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_i >= sizeof(source1_uc)) goto skip76;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> int test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip76: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> unsigned int */
    if (verbose) printf("test for unsigned char >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_u >= sizeof(source1_uc)) goto skip77;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> unsigned int test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip77: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> uintptr_t */
    if (verbose) printf("test for unsigned char >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_ul >= sizeof(source1_uc)) goto skip78;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> uintptr_t test, expected %u, got %u, for %u >> %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip78: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char >> intptr_t */
    if (verbose) printf("test for unsigned char >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_l >= sizeof(source1_uc)) goto skip79;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc >> source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char >> intptr_t test, expected %u, got %u, for %u >> %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip79: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> signed char */
    if (verbose) printf("test for short >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_c >= sizeof(source1_s)) goto skip80;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short >> signed char test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip80: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> unsigned char */
    if (verbose) printf("test for short >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_uc >= sizeof(source1_s)) goto skip81;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short >> unsigned char test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip81: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> short */
    if (verbose) printf("test for short >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_s >= sizeof(source1_s)) goto skip82;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short >> short test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip82: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> unsigned short */
    if (verbose) printf("test for short >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_us >= sizeof(source1_s)) goto skip83;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short >> unsigned short test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip83: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> int */
    if (verbose) printf("test for short >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_i >= sizeof(source1_s)) goto skip84;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short >> int test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip84: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> unsigned int */
    if (verbose) printf("test for short >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_u >= sizeof(source1_s)) goto skip85;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short >> unsigned int test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip85: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> uintptr_t */
    if (verbose) printf("test for short >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_ul >= sizeof(source1_s)) goto skip86;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short >> uintptr_t test, expected %d, got %d, for %d >> %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip86: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short >> intptr_t */
    if (verbose) printf("test for short >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_l >= sizeof(source1_s)) goto skip87;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s >> source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short >> intptr_t test, expected %d, got %d, for %d >> %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip87: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> signed char */
    if (verbose) printf("test for unsigned short >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_c >= sizeof(source1_us)) goto skip88;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> signed char test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip88: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> unsigned char */
    if (verbose) printf("test for unsigned short >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_uc >= sizeof(source1_us)) goto skip89;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> unsigned char test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip89: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> short */
    if (verbose) printf("test for unsigned short >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_s >= sizeof(source1_us)) goto skip90;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> short test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip90: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> unsigned short */
    if (verbose) printf("test for unsigned short >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_us >= sizeof(source1_us)) goto skip91;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> unsigned short test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip91: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> int */
    if (verbose) printf("test for unsigned short >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_i >= sizeof(source1_us)) goto skip92;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> int test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip92: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> unsigned int */
    if (verbose) printf("test for unsigned short >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_u >= sizeof(source1_us)) goto skip93;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> unsigned int test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip93: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> uintptr_t */
    if (verbose) printf("test for unsigned short >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_ul >= sizeof(source1_us)) goto skip94;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> uintptr_t test, expected %u, got %u, for %u >> %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip94: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short >> intptr_t */
    if (verbose) printf("test for unsigned short >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_l >= sizeof(source1_us)) goto skip95;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us >> source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short >> intptr_t test, expected %u, got %u, for %u >> %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip95: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> signed char */
    if (verbose) printf("test for int >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_c >= sizeof(source1_i)) goto skip96;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int >> signed char test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip96: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> unsigned char */
    if (verbose) printf("test for int >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_uc >= sizeof(source1_i)) goto skip97;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int >> unsigned char test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip97: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> short */
    if (verbose) printf("test for int >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_s >= sizeof(source1_i)) goto skip98;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int >> short test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip98: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> unsigned short */
    if (verbose) printf("test for int >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_us >= sizeof(source1_i)) goto skip99;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int >> unsigned short test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip99: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> int */
    if (verbose) printf("test for int >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_i >= sizeof(source1_i)) goto skip100;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int >> int test, expected %d, got %d, for %d >> %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip100: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> unsigned int */
    if (verbose) printf("test for int >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_u >= sizeof(source1_i)) goto skip101;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int >> unsigned int test, expected %d, got %d, for %d >> %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip101: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> uintptr_t */
    if (verbose) printf("test for int >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_ul >= sizeof(source1_i)) goto skip102;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int >> uintptr_t test, expected %d, got %d, for %d >> %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip102: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int >> intptr_t */
    if (verbose) printf("test for int >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_l >= sizeof(source1_i)) goto skip103;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i >> source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int >> intptr_t test, expected %d, got %d, for %d >> %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip103: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> signed char */
    if (verbose) printf("test for unsigned int >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_c >= sizeof(source1_u)) goto skip104;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> signed char test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip104: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> unsigned char */
    if (verbose) printf("test for unsigned int >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_uc >= sizeof(source1_u)) goto skip105;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> unsigned char test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip105: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> short */
    if (verbose) printf("test for unsigned int >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_s >= sizeof(source1_u)) goto skip106;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> short test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip106: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> unsigned short */
    if (verbose) printf("test for unsigned int >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_us >= sizeof(source1_u)) goto skip107;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> unsigned short test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip107: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> int */
    if (verbose) printf("test for unsigned int >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_i >= sizeof(source1_u)) goto skip108;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> int test, expected %u, got %u, for %u >> %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip108: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> unsigned int */
    if (verbose) printf("test for unsigned int >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_u >= sizeof(source1_u)) goto skip109;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> unsigned int test, expected %u, got %u, for %u >> %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip109: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> uintptr_t */
    if (verbose) printf("test for unsigned int >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_ul >= sizeof(source1_u)) goto skip110;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> uintptr_t test, expected %u, got %u, for %u >> %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip110: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int >> intptr_t */
    if (verbose) printf("test for unsigned int >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_l >= sizeof(source1_u)) goto skip111;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u >> source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int >> intptr_t test, expected %u, got %u, for %u >> %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip111: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> signed char */
    if (verbose) printf("test for uintptr_t >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_c >= sizeof(source1_ul)) goto skip112;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> signed char test, expected %zu, got %zu, for %zu >> %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip112: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> unsigned char */
    if (verbose) printf("test for uintptr_t >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_uc >= sizeof(source1_ul)) goto skip113;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> unsigned char test, expected %zu, got %zu, for %zu >> %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip113: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> short */
    if (verbose) printf("test for uintptr_t >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_s >= sizeof(source1_ul)) goto skip114;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> short test, expected %zu, got %zu, for %zu >> %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip114: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> unsigned short */
    if (verbose) printf("test for uintptr_t >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_us >= sizeof(source1_ul)) goto skip115;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> unsigned short test, expected %zu, got %zu, for %zu >> %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip115: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> int */
    if (verbose) printf("test for uintptr_t >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_i >= sizeof(source1_ul)) goto skip116;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> int test, expected %zu, got %zu, for %zu >> %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip116: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> unsigned int */
    if (verbose) printf("test for uintptr_t >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_u >= sizeof(source1_ul)) goto skip117;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> unsigned int test, expected %zu, got %zu, for %zu >> %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip117: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> uintptr_t */
    if (verbose) printf("test for uintptr_t >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_ul >= sizeof(source1_ul)) goto skip118;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> uintptr_t test, expected %zu, got %zu, for %zu >> %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip118: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t >> intptr_t */
    if (verbose) printf("test for uintptr_t >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_l >= sizeof(source1_ul)) goto skip119;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul >> source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t >> intptr_t test, expected %zu, got %zu, for %zu >> %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip119: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void rsh_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> signed char */
    if (verbose) printf("test for intptr_t >> signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            signed char source2_c = sh_src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_c >= sizeof(source1_l)) goto skip120;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t >> signed char test, expected %zd, got %zd, for %zd >> %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip120: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> unsigned char */
    if (verbose) printf("test for intptr_t >> unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2c_vals)/sizeof(sh_src2c_vals[0]) ; j++) {
            unsigned char source2_uc = sh_src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_uc >= sizeof(source1_l)) goto skip121;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t >> unsigned char test, expected %zd, got %zd, for %zd >> %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip121: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> short */
    if (verbose) printf("test for intptr_t >> short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            short source2_s = sh_src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_s >= sizeof(source1_l)) goto skip122;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t >> short test, expected %zd, got %zd, for %zd >> %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip122: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> unsigned short */
    if (verbose) printf("test for intptr_t >> unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2s_vals)/sizeof(sh_src2s_vals[0]) ; j++) {
            unsigned short source2_us = sh_src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_us >= sizeof(source1_l)) goto skip123;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t >> unsigned short test, expected %zd, got %zd, for %zd >> %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip123: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> int */
    if (verbose) printf("test for intptr_t >> int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            int source2_i = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_i >= sizeof(source1_l)) goto skip124;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t >> int test, expected %zd, got %zd, for %zd >> %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip124: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> unsigned int */
    if (verbose) printf("test for intptr_t >> unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            unsigned int source2_u = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_u >= sizeof(source1_l)) goto skip125;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t >> unsigned int test, expected %zd, got %zd, for %zd >> %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip125: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> uintptr_t */
    if (verbose) printf("test for intptr_t >> uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            uintptr_t source2_ul = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_ul >= sizeof(source1_l)) goto skip126;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t >> uintptr_t test, expected %zd, got %zd, for %zd >> %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip126: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l>>l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a >> b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t >> intptr_t */
    if (verbose) printf("test for intptr_t >> intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(sh_src2_vals)/sizeof(sh_src2_vals[0]) ; j++) {
            intptr_t source2_l = sh_src2_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_l >= sizeof(source1_l)) goto skip127;
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l >> source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t >> intptr_t test, expected %zd, got %zd, for %zd >> %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip127: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + signed char */
    if (verbose) printf("test for signed char + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char + signed char test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + unsigned char */
    if (verbose) printf("test for signed char + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char + unsigned char test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + short */
    if (verbose) printf("test for signed char + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char + short test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + unsigned short */
    if (verbose) printf("test for signed char + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char + unsigned short test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + int */
    if (verbose) printf("test for signed char + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char + int test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + unsigned int */
    if (verbose) printf("test for signed char + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char + unsigned int test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + uintptr_t */
    if (verbose) printf("test for signed char + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char + uintptr_t test, expected %d, got %d, for %d + %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + intptr_t */
    if (verbose) printf("test for signed char + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char + intptr_t test, expected %d, got %d, for %d + %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + float */
    if (verbose) printf("test for signed char + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_c) + fabs((double)source2_f));
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_f);

	    result = proc(source1_c, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed signed char + float test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_c, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    signed char (*proc)(signed char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char + double */
    if (verbose) printf("test for signed char + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c + source2_d);

	    result = proc(source1_c, source2_d);
	    if (expected_result != result) {
		printf("Failed signed char + double test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_c, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + signed char */
    if (verbose) printf("test for unsigned char + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + signed char test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + unsigned char */
    if (verbose) printf("test for unsigned char + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + unsigned char test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + short */
    if (verbose) printf("test for unsigned char + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + short test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + unsigned short */
    if (verbose) printf("test for unsigned char + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + unsigned short test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + int */
    if (verbose) printf("test for unsigned char + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + int test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + unsigned int */
    if (verbose) printf("test for unsigned char + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + unsigned int test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + uintptr_t */
    if (verbose) printf("test for unsigned char + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + uintptr_t test, expected %u, got %u, for %u + %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + intptr_t */
    if (verbose) printf("test for unsigned char + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + intptr_t test, expected %u, got %u, for %u + %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + float */
    if (verbose) printf("test for unsigned char + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_uc) + fabs((double)source2_f));
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_f);

	    result = proc(source1_uc, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned char + float test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_uc, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    unsigned char (*proc)(unsigned char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char + double */
    if (verbose) printf("test for unsigned char + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc + source2_d);

	    result = proc(source1_uc, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char + double test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_uc, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + signed char */
    if (verbose) printf("test for short + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short + signed char test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + unsigned char */
    if (verbose) printf("test for short + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short + unsigned char test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + short */
    if (verbose) printf("test for short + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short + short test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + unsigned short */
    if (verbose) printf("test for short + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short + unsigned short test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + int */
    if (verbose) printf("test for short + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short + int test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + unsigned int */
    if (verbose) printf("test for short + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short + unsigned int test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + uintptr_t */
    if (verbose) printf("test for short + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short + uintptr_t test, expected %d, got %d, for %d + %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + intptr_t */
    if (verbose) printf("test for short + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short + intptr_t test, expected %d, got %d, for %d + %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + float */
    if (verbose) printf("test for short + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_s) + fabs((double)source2_f));
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_f);

	    result = proc(source1_s, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed short + float test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_s, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    short (*proc)(short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short + double */
    if (verbose) printf("test for short + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s + source2_d);

	    result = proc(source1_s, source2_d);
	    if (expected_result != result) {
		printf("Failed short + double test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_s, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + signed char */
    if (verbose) printf("test for unsigned short + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + signed char test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + unsigned char */
    if (verbose) printf("test for unsigned short + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + unsigned char test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + short */
    if (verbose) printf("test for unsigned short + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + short test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + unsigned short */
    if (verbose) printf("test for unsigned short + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + unsigned short test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + int */
    if (verbose) printf("test for unsigned short + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + int test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + unsigned int */
    if (verbose) printf("test for unsigned short + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + unsigned int test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + uintptr_t */
    if (verbose) printf("test for unsigned short + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + uintptr_t test, expected %u, got %u, for %u + %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + intptr_t */
    if (verbose) printf("test for unsigned short + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + intptr_t test, expected %u, got %u, for %u + %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + float */
    if (verbose) printf("test for unsigned short + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_us) + fabs((double)source2_f));
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_f);

	    result = proc(source1_us, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned short + float test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_us, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    unsigned short (*proc)(unsigned short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short + double */
    if (verbose) printf("test for unsigned short + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us + source2_d);

	    result = proc(source1_us, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short + double test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_us, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + signed char */
    if (verbose) printf("test for int + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int + signed char test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + unsigned char */
    if (verbose) printf("test for int + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int + unsigned char test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + short */
    if (verbose) printf("test for int + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int + short test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + unsigned short */
    if (verbose) printf("test for int + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int + unsigned short test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + int */
    if (verbose) printf("test for int + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int + int test, expected %d, got %d, for %d + %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + unsigned int */
    if (verbose) printf("test for int + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int + unsigned int test, expected %d, got %d, for %d + %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + uintptr_t */
    if (verbose) printf("test for int + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int + uintptr_t test, expected %d, got %d, for %d + %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + intptr_t */
    if (verbose) printf("test for int + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int + intptr_t test, expected %d, got %d, for %d + %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + float */
    if (verbose) printf("test for int + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_i) + fabs((double)source2_f));
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_f);

	    result = proc(source1_i, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed int + float test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_i, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    int (*proc)(int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int + double */
    if (verbose) printf("test for int + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i + source2_d);

	    result = proc(source1_i, source2_d);
	    if (expected_result != result) {
		printf("Failed int + double test, expected %d, got %d, for %d + %g\n",
		       expected_result, result, source1_i, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + signed char */
    if (verbose) printf("test for unsigned int + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + signed char test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + unsigned char */
    if (verbose) printf("test for unsigned int + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + unsigned char test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + short */
    if (verbose) printf("test for unsigned int + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + short test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + unsigned short */
    if (verbose) printf("test for unsigned int + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + unsigned short test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + int */
    if (verbose) printf("test for unsigned int + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + int test, expected %u, got %u, for %u + %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + unsigned int */
    if (verbose) printf("test for unsigned int + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + unsigned int test, expected %u, got %u, for %u + %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + uintptr_t */
    if (verbose) printf("test for unsigned int + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + uintptr_t test, expected %u, got %u, for %u + %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + intptr_t */
    if (verbose) printf("test for unsigned int + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + intptr_t test, expected %u, got %u, for %u + %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + float */
    if (verbose) printf("test for unsigned int + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_u) + fabs((double)source2_f));
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_f);

	    result = proc(source1_u, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned int + float test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_u, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    unsigned int (*proc)(unsigned int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int + double */
    if (verbose) printf("test for unsigned int + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u + source2_d);

	    result = proc(source1_u, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int + double test, expected %u, got %u, for %u + %g\n",
		       expected_result, result, source1_u, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + signed char */
    if (verbose) printf("test for uintptr_t + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + signed char test, expected %zu, got %zu, for %zu + %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + unsigned char */
    if (verbose) printf("test for uintptr_t + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + unsigned char test, expected %zu, got %zu, for %zu + %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + short */
    if (verbose) printf("test for uintptr_t + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + short test, expected %zu, got %zu, for %zu + %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + unsigned short */
    if (verbose) printf("test for uintptr_t + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + unsigned short test, expected %zu, got %zu, for %zu + %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + int */
    if (verbose) printf("test for uintptr_t + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + int test, expected %zu, got %zu, for %zu + %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + unsigned int */
    if (verbose) printf("test for uintptr_t + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + unsigned int test, expected %zu, got %zu, for %zu + %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + uintptr_t */
    if (verbose) printf("test for uintptr_t + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + uintptr_t test, expected %zu, got %zu, for %zu + %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + intptr_t */
    if (verbose) printf("test for uintptr_t + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + intptr_t test, expected %zu, got %zu, for %zu + %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + float */
    if (verbose) printf("test for uintptr_t + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_ul) + fabs((double)source2_f));
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_f);

	    result = proc(source1_ul, source2_f);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed uintptr_t + float test, expected %zu, got %zu, for %zu + %g\n",
		       expected_result, result, source1_ul, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t + double */
    if (verbose) printf("test for uintptr_t + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul + source2_d);

	    result = proc(source1_ul, source2_d);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t + double test, expected %zu, got %zu, for %zu + %g\n",
		       expected_result, result, source1_ul, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + signed char */
    if (verbose) printf("test for intptr_t + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t + signed char test, expected %zd, got %zd, for %zd + %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + unsigned char */
    if (verbose) printf("test for intptr_t + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t + unsigned char test, expected %zd, got %zd, for %zd + %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + short */
    if (verbose) printf("test for intptr_t + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t + short test, expected %zd, got %zd, for %zd + %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + unsigned short */
    if (verbose) printf("test for intptr_t + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t + unsigned short test, expected %zd, got %zd, for %zd + %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + int */
    if (verbose) printf("test for intptr_t + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t + int test, expected %zd, got %zd, for %zd + %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + unsigned int */
    if (verbose) printf("test for intptr_t + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t + unsigned int test, expected %zd, got %zd, for %zd + %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + uintptr_t */
    if (verbose) printf("test for intptr_t + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t + uintptr_t test, expected %zd, got %zd, for %zd + %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + intptr_t */
    if (verbose) printf("test for intptr_t + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t + intptr_t test, expected %zd, got %zd, for %zd + %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + float */
    if (verbose) printf("test for intptr_t + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_l) + fabs((double)source2_f));
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_f);

	    result = proc(source1_l, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed intptr_t + float test, expected %zd, got %zd, for %zd + %g\n",
		       expected_result, result, source1_l, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    intptr_t (*proc)(intptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t + double */
    if (verbose) printf("test for intptr_t + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l + source2_d);

	    result = proc(source1_l, source2_d);
	    if (expected_result != result) {
		printf("Failed intptr_t + double test, expected %zd, got %zd, for %zd + %g\n",
		       expected_result, result, source1_l, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_f_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + signed char */
    if (verbose) printf("test for float + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_c));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_c);

	    result = proc(source1_f, source2_c);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + signed char test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_f, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + unsigned char */
    if (verbose) printf("test for float + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_uc));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_uc);

	    result = proc(source1_f, source2_uc);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + unsigned char test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_f, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + short */
    if (verbose) printf("test for float + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_s));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_s);

	    result = proc(source1_f, source2_s);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + short test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_f, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + unsigned short */
    if (verbose) printf("test for float + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_us));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_us);

	    result = proc(source1_f, source2_us);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + unsigned short test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_f, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + int */
    if (verbose) printf("test for float + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_i));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_i);

	    result = proc(source1_f, source2_i);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + int test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_f, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + unsigned int */
    if (verbose) printf("test for float + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_u));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_u);

	    result = proc(source1_f, source2_u);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + unsigned int test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_f, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + uintptr_t */
    if (verbose) printf("test for float + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_ul));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_ul);

	    result = proc(source1_f, source2_ul);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + uintptr_t test, expected %g, got %g, for %g + %zu\n",
		       expected_result, result, source1_f, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + intptr_t */
    if (verbose) printf("test for float + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_l));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_l);

	    result = proc(source1_f, source2_l);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + intptr_t test, expected %g, got %g, for %g + %zd\n",
		       expected_result, result, source1_f, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + float */
    if (verbose) printf("test for float + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_f));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_f);

	    result = proc(source1_f, source2_f);
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + float test, expected %g, got %g, for %g + %g\n",
		       expected_result, result, source1_f, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    float (*proc)(float a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float + double */
    if (verbose) printf("test for float + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_d));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f + source2_d);

	    result = proc(source1_f, source2_d);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float + double test, expected %g, got %g, for %g + %g\n",
		       expected_result, result, source1_f, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void add_d_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       signed char b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + signed char */
    if (verbose) printf("test for double + signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_c);

	    result = proc(source1_d, source2_c);
	    if (expected_result != result) {
		printf("Failed double + signed char test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_d, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned char b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + unsigned char */
    if (verbose) printf("test for double + unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_uc);

	    result = proc(source1_d, source2_uc);
	    if (expected_result != result) {
		printf("Failed double + unsigned char test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_d, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       short b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + short */
    if (verbose) printf("test for double + short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_s);

	    result = proc(source1_d, source2_s);
	    if (expected_result != result) {
		printf("Failed double + short test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_d, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned short b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + unsigned short */
    if (verbose) printf("test for double + unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_us);

	    result = proc(source1_d, source2_us);
	    if (expected_result != result) {
		printf("Failed double + unsigned short test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_d, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       int b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + int */
    if (verbose) printf("test for double + int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_i);

	    result = proc(source1_d, source2_i);
	    if (expected_result != result) {
		printf("Failed double + int test, expected %g, got %g, for %g + %d\n",
		       expected_result, result, source1_d, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned int b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + unsigned int */
    if (verbose) printf("test for double + unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_u);

	    result = proc(source1_d, source2_u);
	    if (expected_result != result) {
		printf("Failed double + unsigned int test, expected %g, got %g, for %g + %u\n",
		       expected_result, result, source1_d, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned long b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + uintptr_t */
    if (verbose) printf("test for double + uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_ul);

	    result = proc(source1_d, source2_ul);
	    if (expected_result != result) {
		printf("Failed double + uintptr_t test, expected %g, got %g, for %g + %zu\n",
		       expected_result, result, source1_d, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       long b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + intptr_t */
    if (verbose) printf("test for double + intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_l);

	    result = proc(source1_d, source2_l);
	    if (expected_result != result) {
		printf("Failed double + intptr_t test, expected %g, got %g, for %g + %zd\n",
		       expected_result, result, source1_d, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       float b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + float */
    if (verbose) printf("test for double + float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_d) + fabs((double)source2_f));
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_f);

	    result = proc(source1_d, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed double + float test, expected %g, got %g, for %g + %g\n",
		       expected_result, result, source1_d, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d+d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       double b = p2;\n\
       return a + b;\n\
     }";

    double (*proc)(double a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double + double */
    if (verbose) printf("test for double + double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d + source2_d);

	    result = proc(source1_d, source2_d);
	    if (expected_result != result) {
		printf("Failed double + double test, expected %g, got %g, for %g + %g\n",
		       expected_result, result, source1_d, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - signed char */
    if (verbose) printf("test for signed char - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char - signed char test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - unsigned char */
    if (verbose) printf("test for signed char - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char - unsigned char test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - short */
    if (verbose) printf("test for signed char - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char - short test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - unsigned short */
    if (verbose) printf("test for signed char - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char - unsigned short test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - int */
    if (verbose) printf("test for signed char - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char - int test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - unsigned int */
    if (verbose) printf("test for signed char - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char - unsigned int test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - uintptr_t */
    if (verbose) printf("test for signed char - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char - uintptr_t test, expected %d, got %d, for %d - %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - intptr_t */
    if (verbose) printf("test for signed char - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char - intptr_t test, expected %d, got %d, for %d - %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - float */
    if (verbose) printf("test for signed char - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_c) + fabs((double)source2_f));
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_f);

	    result = proc(source1_c, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed signed char - float test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_c, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    signed char (*proc)(signed char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char - double */
    if (verbose) printf("test for signed char - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c - source2_d);

	    result = proc(source1_c, source2_d);
	    if (expected_result != result) {
		printf("Failed signed char - double test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_c, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - signed char */
    if (verbose) printf("test for unsigned char - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - signed char test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - unsigned char */
    if (verbose) printf("test for unsigned char - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - unsigned char test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - short */
    if (verbose) printf("test for unsigned char - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - short test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - unsigned short */
    if (verbose) printf("test for unsigned char - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - unsigned short test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - int */
    if (verbose) printf("test for unsigned char - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - int test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - unsigned int */
    if (verbose) printf("test for unsigned char - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - unsigned int test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - uintptr_t */
    if (verbose) printf("test for unsigned char - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - uintptr_t test, expected %u, got %u, for %u - %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - intptr_t */
    if (verbose) printf("test for unsigned char - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - intptr_t test, expected %u, got %u, for %u - %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - float */
    if (verbose) printf("test for unsigned char - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_uc) + fabs((double)source2_f));
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_f);

	    result = proc(source1_uc, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned char - float test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_uc, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    unsigned char (*proc)(unsigned char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char - double */
    if (verbose) printf("test for unsigned char - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc - source2_d);

	    result = proc(source1_uc, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char - double test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_uc, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - signed char */
    if (verbose) printf("test for short - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short - signed char test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - unsigned char */
    if (verbose) printf("test for short - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short - unsigned char test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - short */
    if (verbose) printf("test for short - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short - short test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - unsigned short */
    if (verbose) printf("test for short - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short - unsigned short test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - int */
    if (verbose) printf("test for short - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short - int test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - unsigned int */
    if (verbose) printf("test for short - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short - unsigned int test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - uintptr_t */
    if (verbose) printf("test for short - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short - uintptr_t test, expected %d, got %d, for %d - %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - intptr_t */
    if (verbose) printf("test for short - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short - intptr_t test, expected %d, got %d, for %d - %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - float */
    if (verbose) printf("test for short - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_s) + fabs((double)source2_f));
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_f);

	    result = proc(source1_s, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed short - float test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_s, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    short (*proc)(short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short - double */
    if (verbose) printf("test for short - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s - source2_d);

	    result = proc(source1_s, source2_d);
	    if (expected_result != result) {
		printf("Failed short - double test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_s, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - signed char */
    if (verbose) printf("test for unsigned short - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - signed char test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - unsigned char */
    if (verbose) printf("test for unsigned short - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - unsigned char test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - short */
    if (verbose) printf("test for unsigned short - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - short test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - unsigned short */
    if (verbose) printf("test for unsigned short - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - unsigned short test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - int */
    if (verbose) printf("test for unsigned short - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - int test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - unsigned int */
    if (verbose) printf("test for unsigned short - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - unsigned int test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - uintptr_t */
    if (verbose) printf("test for unsigned short - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - uintptr_t test, expected %u, got %u, for %u - %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - intptr_t */
    if (verbose) printf("test for unsigned short - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - intptr_t test, expected %u, got %u, for %u - %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - float */
    if (verbose) printf("test for unsigned short - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_us) + fabs((double)source2_f));
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_f);

	    result = proc(source1_us, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned short - float test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_us, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    unsigned short (*proc)(unsigned short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short - double */
    if (verbose) printf("test for unsigned short - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us - source2_d);

	    result = proc(source1_us, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short - double test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_us, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - signed char */
    if (verbose) printf("test for int - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int - signed char test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - unsigned char */
    if (verbose) printf("test for int - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int - unsigned char test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - short */
    if (verbose) printf("test for int - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int - short test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - unsigned short */
    if (verbose) printf("test for int - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int - unsigned short test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - int */
    if (verbose) printf("test for int - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int - int test, expected %d, got %d, for %d - %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - unsigned int */
    if (verbose) printf("test for int - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int - unsigned int test, expected %d, got %d, for %d - %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - uintptr_t */
    if (verbose) printf("test for int - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int - uintptr_t test, expected %d, got %d, for %d - %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - intptr_t */
    if (verbose) printf("test for int - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int - intptr_t test, expected %d, got %d, for %d - %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - float */
    if (verbose) printf("test for int - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_i) + fabs((double)source2_f));
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_f);

	    result = proc(source1_i, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed int - float test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_i, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    int (*proc)(int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int - double */
    if (verbose) printf("test for int - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i - source2_d);

	    result = proc(source1_i, source2_d);
	    if (expected_result != result) {
		printf("Failed int - double test, expected %d, got %d, for %d - %g\n",
		       expected_result, result, source1_i, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - signed char */
    if (verbose) printf("test for unsigned int - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - signed char test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - unsigned char */
    if (verbose) printf("test for unsigned int - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - unsigned char test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - short */
    if (verbose) printf("test for unsigned int - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - short test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - unsigned short */
    if (verbose) printf("test for unsigned int - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - unsigned short test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - int */
    if (verbose) printf("test for unsigned int - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - int test, expected %u, got %u, for %u - %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - unsigned int */
    if (verbose) printf("test for unsigned int - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - unsigned int test, expected %u, got %u, for %u - %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - uintptr_t */
    if (verbose) printf("test for unsigned int - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - uintptr_t test, expected %u, got %u, for %u - %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - intptr_t */
    if (verbose) printf("test for unsigned int - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - intptr_t test, expected %u, got %u, for %u - %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - float */
    if (verbose) printf("test for unsigned int - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_u) + fabs((double)source2_f));
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_f);

	    result = proc(source1_u, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned int - float test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_u, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    unsigned int (*proc)(unsigned int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int - double */
    if (verbose) printf("test for unsigned int - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u - source2_d);

	    result = proc(source1_u, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int - double test, expected %u, got %u, for %u - %g\n",
		       expected_result, result, source1_u, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - signed char */
    if (verbose) printf("test for uintptr_t - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - signed char test, expected %zu, got %zu, for %zu - %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - unsigned char */
    if (verbose) printf("test for uintptr_t - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - unsigned char test, expected %zu, got %zu, for %zu - %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - short */
    if (verbose) printf("test for uintptr_t - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - short test, expected %zu, got %zu, for %zu - %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - unsigned short */
    if (verbose) printf("test for uintptr_t - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - unsigned short test, expected %zu, got %zu, for %zu - %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - int */
    if (verbose) printf("test for uintptr_t - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - int test, expected %zu, got %zu, for %zu - %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - unsigned int */
    if (verbose) printf("test for uintptr_t - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - unsigned int test, expected %zu, got %zu, for %zu - %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - uintptr_t */
    if (verbose) printf("test for uintptr_t - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - uintptr_t test, expected %zu, got %zu, for %zu - %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - intptr_t */
    if (verbose) printf("test for uintptr_t - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - intptr_t test, expected %zu, got %zu, for %zu - %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - float */
    if (verbose) printf("test for uintptr_t - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_ul) + fabs((double)source2_f));
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_f);

	    result = proc(source1_ul, source2_f);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed uintptr_t - float test, expected %zu, got %zu, for %zu - %g\n",
		       expected_result, result, source1_ul, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t - double */
    if (verbose) printf("test for uintptr_t - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul - source2_d);

	    result = proc(source1_ul, source2_d);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t - double test, expected %zu, got %zu, for %zu - %g\n",
		       expected_result, result, source1_ul, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - signed char */
    if (verbose) printf("test for intptr_t - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t - signed char test, expected %zd, got %zd, for %zd - %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - unsigned char */
    if (verbose) printf("test for intptr_t - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t - unsigned char test, expected %zd, got %zd, for %zd - %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - short */
    if (verbose) printf("test for intptr_t - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t - short test, expected %zd, got %zd, for %zd - %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - unsigned short */
    if (verbose) printf("test for intptr_t - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t - unsigned short test, expected %zd, got %zd, for %zd - %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - int */
    if (verbose) printf("test for intptr_t - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t - int test, expected %zd, got %zd, for %zd - %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - unsigned int */
    if (verbose) printf("test for intptr_t - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t - unsigned int test, expected %zd, got %zd, for %zd - %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - uintptr_t */
    if (verbose) printf("test for intptr_t - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t - uintptr_t test, expected %zd, got %zd, for %zd - %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - intptr_t */
    if (verbose) printf("test for intptr_t - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t - intptr_t test, expected %zd, got %zd, for %zd - %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - float */
    if (verbose) printf("test for intptr_t - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_l) + fabs((double)source2_f));
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_f);

	    result = proc(source1_l, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed intptr_t - float test, expected %zd, got %zd, for %zd - %g\n",
		       expected_result, result, source1_l, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    intptr_t (*proc)(intptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t - double */
    if (verbose) printf("test for intptr_t - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l - source2_d);

	    result = proc(source1_l, source2_d);
	    if (expected_result != result) {
		printf("Failed intptr_t - double test, expected %zd, got %zd, for %zd - %g\n",
		       expected_result, result, source1_l, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_f_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - signed char */
    if (verbose) printf("test for float - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_c));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_c);

	    result = proc(source1_f, source2_c);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - signed char test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_f, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - unsigned char */
    if (verbose) printf("test for float - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_uc));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_uc);

	    result = proc(source1_f, source2_uc);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - unsigned char test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_f, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - short */
    if (verbose) printf("test for float - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_s));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_s);

	    result = proc(source1_f, source2_s);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - short test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_f, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - unsigned short */
    if (verbose) printf("test for float - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_us));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_us);

	    result = proc(source1_f, source2_us);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - unsigned short test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_f, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - int */
    if (verbose) printf("test for float - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_i));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_i);

	    result = proc(source1_f, source2_i);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - int test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_f, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - unsigned int */
    if (verbose) printf("test for float - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_u));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_u);

	    result = proc(source1_f, source2_u);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - unsigned int test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_f, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - uintptr_t */
    if (verbose) printf("test for float - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_ul));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_ul);

	    result = proc(source1_f, source2_ul);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - uintptr_t test, expected %g, got %g, for %g - %zu\n",
		       expected_result, result, source1_f, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - intptr_t */
    if (verbose) printf("test for float - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_l));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_l);

	    result = proc(source1_f, source2_l);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - intptr_t test, expected %g, got %g, for %g - %zd\n",
		       expected_result, result, source1_f, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - float */
    if (verbose) printf("test for float - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_f));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_f);

	    result = proc(source1_f, source2_f);
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - float test, expected %g, got %g, for %g - %g\n",
		       expected_result, result, source1_f, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    float (*proc)(float a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float - double */
    if (verbose) printf("test for float - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f) + fabs((double)source2_d));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f - source2_d);

	    result = proc(source1_f, source2_d);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float - double test, expected %g, got %g, for %g - %g\n",
		       expected_result, result, source1_f, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void sub_d_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       signed char b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - signed char */
    if (verbose) printf("test for double - signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_c);

	    result = proc(source1_d, source2_c);
	    if (expected_result != result) {
		printf("Failed double - signed char test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_d, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned char b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - unsigned char */
    if (verbose) printf("test for double - unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_uc);

	    result = proc(source1_d, source2_uc);
	    if (expected_result != result) {
		printf("Failed double - unsigned char test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_d, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       short b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - short */
    if (verbose) printf("test for double - short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_s);

	    result = proc(source1_d, source2_s);
	    if (expected_result != result) {
		printf("Failed double - short test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_d, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned short b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - unsigned short */
    if (verbose) printf("test for double - unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_us);

	    result = proc(source1_d, source2_us);
	    if (expected_result != result) {
		printf("Failed double - unsigned short test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_d, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       int b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - int */
    if (verbose) printf("test for double - int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_i);

	    result = proc(source1_d, source2_i);
	    if (expected_result != result) {
		printf("Failed double - int test, expected %g, got %g, for %g - %d\n",
		       expected_result, result, source1_d, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned int b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - unsigned int */
    if (verbose) printf("test for double - unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_u);

	    result = proc(source1_d, source2_u);
	    if (expected_result != result) {
		printf("Failed double - unsigned int test, expected %g, got %g, for %g - %u\n",
		       expected_result, result, source1_d, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned long b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - uintptr_t */
    if (verbose) printf("test for double - uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_ul);

	    result = proc(source1_d, source2_ul);
	    if (expected_result != result) {
		printf("Failed double - uintptr_t test, expected %g, got %g, for %g - %zu\n",
		       expected_result, result, source1_d, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       long b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - intptr_t */
    if (verbose) printf("test for double - intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_l);

	    result = proc(source1_d, source2_l);
	    if (expected_result != result) {
		printf("Failed double - intptr_t test, expected %g, got %g, for %g - %zd\n",
		       expected_result, result, source1_d, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       float b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - float */
    if (verbose) printf("test for double - float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_d) + fabs((double)source2_f));
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_f);

	    result = proc(source1_d, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed double - float test, expected %g, got %g, for %g - %g\n",
		       expected_result, result, source1_d, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d-d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       double b = p2;\n\
       return a - b;\n\
     }";

    double (*proc)(double a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double - double */
    if (verbose) printf("test for double - double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d - source2_d);

	    result = proc(source1_d, source2_d);
	    if (expected_result != result) {
		printf("Failed double - double test, expected %g, got %g, for %g - %g\n",
		       expected_result, result, source1_d, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * signed char */
    if (verbose) printf("test for signed char * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char * signed char test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * unsigned char */
    if (verbose) printf("test for signed char * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char * unsigned char test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * short */
    if (verbose) printf("test for signed char * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char * short test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * unsigned short */
    if (verbose) printf("test for signed char * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char * unsigned short test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * int */
    if (verbose) printf("test for signed char * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char * int test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * unsigned int */
    if (verbose) printf("test for signed char * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char * unsigned int test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * uintptr_t */
    if (verbose) printf("test for signed char * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char * uintptr_t test, expected %d, got %d, for %d * %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * intptr_t */
    if (verbose) printf("test for signed char * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char * intptr_t test, expected %d, got %d, for %d * %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * float */
    if (verbose) printf("test for signed char * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_c * (double)source2_f));
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_f);

	    result = proc(source1_c, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed signed char * float test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_c, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    signed char (*proc)(signed char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char * double */
    if (verbose) printf("test for signed char * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c * source2_d);

	    result = proc(source1_c, source2_d);
	    if (expected_result != result) {
		printf("Failed signed char * double test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_c, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * signed char */
    if (verbose) printf("test for unsigned char * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_c);

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * signed char test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * unsigned char */
    if (verbose) printf("test for unsigned char * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_uc);

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * unsigned char test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * short */
    if (verbose) printf("test for unsigned char * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_s);

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * short test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * unsigned short */
    if (verbose) printf("test for unsigned char * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_us);

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * unsigned short test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * int */
    if (verbose) printf("test for unsigned char * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_i);

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * int test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * unsigned int */
    if (verbose) printf("test for unsigned char * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_u);

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * unsigned int test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * uintptr_t */
    if (verbose) printf("test for unsigned char * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_ul);

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * uintptr_t test, expected %u, got %u, for %u * %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * intptr_t */
    if (verbose) printf("test for unsigned char * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_l);

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * intptr_t test, expected %u, got %u, for %u * %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * float */
    if (verbose) printf("test for unsigned char * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_uc * (double)source2_f));
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_f);

	    result = proc(source1_uc, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned char * float test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_uc, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    unsigned char (*proc)(unsigned char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char * double */
    if (verbose) printf("test for unsigned char * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned char expected_result;
	    unsigned char result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) (source1_uc * source2_d);

	    result = proc(source1_uc, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char * double test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_uc, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * signed char */
    if (verbose) printf("test for short * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short * signed char test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * unsigned char */
    if (verbose) printf("test for short * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short * unsigned char test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * short */
    if (verbose) printf("test for short * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short * short test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * unsigned short */
    if (verbose) printf("test for short * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short * unsigned short test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * int */
    if (verbose) printf("test for short * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short * int test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * unsigned int */
    if (verbose) printf("test for short * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short * unsigned int test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * uintptr_t */
    if (verbose) printf("test for short * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short * uintptr_t test, expected %d, got %d, for %d * %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * intptr_t */
    if (verbose) printf("test for short * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short * intptr_t test, expected %d, got %d, for %d * %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * float */
    if (verbose) printf("test for short * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_s * (double)source2_f));
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_f);

	    result = proc(source1_s, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed short * float test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_s, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    short (*proc)(short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short * double */
    if (verbose) printf("test for short * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    short expected_result;
	    short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s * source2_d);

	    result = proc(source1_s, source2_d);
	    if (expected_result != result) {
		printf("Failed short * double test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_s, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * signed char */
    if (verbose) printf("test for unsigned short * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * signed char test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * unsigned char */
    if (verbose) printf("test for unsigned short * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * unsigned char test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * short */
    if (verbose) printf("test for unsigned short * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * short test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * unsigned short */
    if (verbose) printf("test for unsigned short * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * unsigned short test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * int */
    if (verbose) printf("test for unsigned short * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * int test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * unsigned int */
    if (verbose) printf("test for unsigned short * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * unsigned int test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * uintptr_t */
    if (verbose) printf("test for unsigned short * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * uintptr_t test, expected %u, got %u, for %u * %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * intptr_t */
    if (verbose) printf("test for unsigned short * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * intptr_t test, expected %u, got %u, for %u * %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * float */
    if (verbose) printf("test for unsigned short * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_us * (double)source2_f));
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_f);

	    result = proc(source1_us, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned short * float test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_us, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    unsigned short (*proc)(unsigned short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short * double */
    if (verbose) printf("test for unsigned short * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us * source2_d);

	    result = proc(source1_us, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short * double test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_us, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * signed char */
    if (verbose) printf("test for int * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int * signed char test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * unsigned char */
    if (verbose) printf("test for int * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int * unsigned char test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * short */
    if (verbose) printf("test for int * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int * short test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * unsigned short */
    if (verbose) printf("test for int * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int * unsigned short test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * int */
    if (verbose) printf("test for int * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int * int test, expected %d, got %d, for %d * %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * unsigned int */
    if (verbose) printf("test for int * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int * unsigned int test, expected %d, got %d, for %d * %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * uintptr_t */
    if (verbose) printf("test for int * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int * uintptr_t test, expected %d, got %d, for %d * %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * intptr_t */
    if (verbose) printf("test for int * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int * intptr_t test, expected %d, got %d, for %d * %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * float */
    if (verbose) printf("test for int * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_i * (double)source2_f));
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_f);

	    result = proc(source1_i, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed int * float test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_i, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    int (*proc)(int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int * double */
    if (verbose) printf("test for int * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    int expected_result;
	    int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i * source2_d);

	    result = proc(source1_i, source2_d);
	    if (expected_result != result) {
		printf("Failed int * double test, expected %d, got %d, for %d * %g\n",
		       expected_result, result, source1_i, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * signed char */
    if (verbose) printf("test for unsigned int * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * signed char test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * unsigned char */
    if (verbose) printf("test for unsigned int * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * unsigned char test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * short */
    if (verbose) printf("test for unsigned int * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * short test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * unsigned short */
    if (verbose) printf("test for unsigned int * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * unsigned short test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * int */
    if (verbose) printf("test for unsigned int * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * int test, expected %u, got %u, for %u * %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * unsigned int */
    if (verbose) printf("test for unsigned int * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * unsigned int test, expected %u, got %u, for %u * %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * uintptr_t */
    if (verbose) printf("test for unsigned int * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * uintptr_t test, expected %u, got %u, for %u * %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * intptr_t */
    if (verbose) printf("test for unsigned int * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * intptr_t test, expected %u, got %u, for %u * %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * float */
    if (verbose) printf("test for unsigned int * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_u * (double)source2_f));
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_f);

	    result = proc(source1_u, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned int * float test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_u, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    unsigned int (*proc)(unsigned int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int * double */
    if (verbose) printf("test for unsigned int * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u * source2_d);

	    result = proc(source1_u, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int * double test, expected %u, got %u, for %u * %g\n",
		       expected_result, result, source1_u, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * signed char */
    if (verbose) printf("test for uintptr_t * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * signed char test, expected %zu, got %zu, for %zu * %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * unsigned char */
    if (verbose) printf("test for uintptr_t * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * unsigned char test, expected %zu, got %zu, for %zu * %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * short */
    if (verbose) printf("test for uintptr_t * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * short test, expected %zu, got %zu, for %zu * %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * unsigned short */
    if (verbose) printf("test for uintptr_t * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * unsigned short test, expected %zu, got %zu, for %zu * %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * int */
    if (verbose) printf("test for uintptr_t * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * int test, expected %zu, got %zu, for %zu * %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * unsigned int */
    if (verbose) printf("test for uintptr_t * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * unsigned int test, expected %zu, got %zu, for %zu * %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * uintptr_t */
    if (verbose) printf("test for uintptr_t * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * uintptr_t test, expected %zu, got %zu, for %zu * %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * intptr_t */
    if (verbose) printf("test for uintptr_t * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * intptr_t test, expected %zu, got %zu, for %zu * %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * float */
    if (verbose) printf("test for uintptr_t * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_ul * (double)source2_f));
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_f);

	    result = proc(source1_ul, source2_f);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed uintptr_t * float test, expected %zu, got %zu, for %zu * %g\n",
		       expected_result, result, source1_ul, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t * double */
    if (verbose) printf("test for uintptr_t * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul * source2_d);

	    result = proc(source1_ul, source2_d);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t * double test, expected %zu, got %zu, for %zu * %g\n",
		       expected_result, result, source1_ul, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * signed char */
    if (verbose) printf("test for intptr_t * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t * signed char test, expected %zd, got %zd, for %zd * %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * unsigned char */
    if (verbose) printf("test for intptr_t * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t * unsigned char test, expected %zd, got %zd, for %zd * %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * short */
    if (verbose) printf("test for intptr_t * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t * short test, expected %zd, got %zd, for %zd * %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * unsigned short */
    if (verbose) printf("test for intptr_t * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t * unsigned short test, expected %zd, got %zd, for %zd * %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * int */
    if (verbose) printf("test for intptr_t * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t * int test, expected %zd, got %zd, for %zd * %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * unsigned int */
    if (verbose) printf("test for intptr_t * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t * unsigned int test, expected %zd, got %zd, for %zd * %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * uintptr_t */
    if (verbose) printf("test for intptr_t * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t * uintptr_t test, expected %zd, got %zd, for %zd * %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * intptr_t */
    if (verbose) printf("test for intptr_t * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t * intptr_t test, expected %zd, got %zd, for %zd * %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * float */
    if (verbose) printf("test for intptr_t * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_l * (double)source2_f));
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_f);

	    result = proc(source1_l, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed intptr_t * float test, expected %zd, got %zd, for %zd * %g\n",
		       expected_result, result, source1_l, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    intptr_t (*proc)(intptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t * double */
    if (verbose) printf("test for intptr_t * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l * source2_d);

	    result = proc(source1_l, source2_d);
	    if (expected_result != result) {
		printf("Failed intptr_t * double test, expected %zd, got %zd, for %zd * %g\n",
		       expected_result, result, source1_l, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_f_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * signed char */
    if (verbose) printf("test for float * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_c));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_c);

	    result = proc(source1_f, source2_c);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * signed char test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_f, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * unsigned char */
    if (verbose) printf("test for float * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_uc));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_uc);

	    result = proc(source1_f, source2_uc);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * unsigned char test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_f, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * short */
    if (verbose) printf("test for float * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_s));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_s);

	    result = proc(source1_f, source2_s);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * short test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_f, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * unsigned short */
    if (verbose) printf("test for float * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_us));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_us);

	    result = proc(source1_f, source2_us);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * unsigned short test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_f, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * int */
    if (verbose) printf("test for float * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_i));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_i);

	    result = proc(source1_f, source2_i);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * int test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_f, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * unsigned int */
    if (verbose) printf("test for float * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_u));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_u);

	    result = proc(source1_f, source2_u);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * unsigned int test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_f, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * uintptr_t */
    if (verbose) printf("test for float * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_ul));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_ul);

	    result = proc(source1_f, source2_ul);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * uintptr_t test, expected %g, got %g, for %g * %zu\n",
		       expected_result, result, source1_f, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * intptr_t */
    if (verbose) printf("test for float * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_l));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_l);

	    result = proc(source1_f, source2_l);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * intptr_t test, expected %g, got %g, for %g * %zd\n",
		       expected_result, result, source1_f, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * float */
    if (verbose) printf("test for float * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_f));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_f);

	    result = proc(source1_f, source2_f);
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * float test, expected %g, got %g, for %g * %g\n",
		       expected_result, result, source1_f, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    float (*proc)(float a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float * double */
    if (verbose) printf("test for float * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f * (double)source2_d));
	    float expected_result;
	    float result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f * source2_d);

	    result = proc(source1_f, source2_d);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float * double test, expected %g, got %g, for %g * %g\n",
		       expected_result, result, source1_f, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void mult_d_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       signed char b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * signed char */
    if (verbose) printf("test for double * signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_c);

	    result = proc(source1_d, source2_c);
	    if (expected_result != result) {
		printf("Failed double * signed char test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_d, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned char b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * unsigned char */
    if (verbose) printf("test for double * unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_uc);

	    result = proc(source1_d, source2_uc);
	    if (expected_result != result) {
		printf("Failed double * unsigned char test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_d, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       short b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * short */
    if (verbose) printf("test for double * short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_s);

	    result = proc(source1_d, source2_s);
	    if (expected_result != result) {
		printf("Failed double * short test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_d, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned short b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * unsigned short */
    if (verbose) printf("test for double * unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_us);

	    result = proc(source1_d, source2_us);
	    if (expected_result != result) {
		printf("Failed double * unsigned short test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_d, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       int b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * int */
    if (verbose) printf("test for double * int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_i);

	    result = proc(source1_d, source2_i);
	    if (expected_result != result) {
		printf("Failed double * int test, expected %g, got %g, for %g * %d\n",
		       expected_result, result, source1_d, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned int b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * unsigned int */
    if (verbose) printf("test for double * unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_u);

	    result = proc(source1_d, source2_u);
	    if (expected_result != result) {
		printf("Failed double * unsigned int test, expected %g, got %g, for %g * %u\n",
		       expected_result, result, source1_d, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned long b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * uintptr_t */
    if (verbose) printf("test for double * uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_ul);

	    result = proc(source1_d, source2_ul);
	    if (expected_result != result) {
		printf("Failed double * uintptr_t test, expected %g, got %g, for %g * %zu\n",
		       expected_result, result, source1_d, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       long b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * intptr_t */
    if (verbose) printf("test for double * intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_l);

	    result = proc(source1_d, source2_l);
	    if (expected_result != result) {
		printf("Failed double * intptr_t test, expected %g, got %g, for %g * %zd\n",
		       expected_result, result, source1_d, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       float b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * float */
    if (verbose) printf("test for double * float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_d * (double)source2_f));
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_f);

	    result = proc(source1_d, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed double * float test, expected %g, got %g, for %g * %g\n",
		       expected_result, result, source1_d, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d*d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       double b = p2;\n\
       return a * b;\n\
     }";

    double (*proc)(double a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double * double */
    if (verbose) printf("test for double * double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    double expected_result;
	    double result;

	    
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d * source2_d);

	    result = proc(source1_d, source2_d);
	    if (expected_result != result) {
		printf("Failed double * double test, expected %g, got %g, for %g * %g\n",
		       expected_result, result, source1_d, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_c_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / signed char */
    if (verbose) printf("test for signed char / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip128;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_c);

	    result = proc(source1_c, source2_c);
	    if (expected_result != result) {
		printf("Failed signed char / signed char test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_c, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip128: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / unsigned char */
    if (verbose) printf("test for signed char / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip129;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_uc);

	    result = proc(source1_c, source2_uc);
	    if (expected_result != result) {
		printf("Failed signed char / unsigned char test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_c, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip129: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / short */
    if (verbose) printf("test for signed char / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip130;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_s);

	    result = proc(source1_c, source2_s);
	    if (expected_result != result) {
		printf("Failed signed char / short test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_c, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip130: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / unsigned short */
    if (verbose) printf("test for signed char / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip131;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_us);

	    result = proc(source1_c, source2_us);
	    if (expected_result != result) {
		printf("Failed signed char / unsigned short test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_c, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip131: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / int */
    if (verbose) printf("test for signed char / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip132;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_i);

	    result = proc(source1_c, source2_i);
	    if (expected_result != result) {
		printf("Failed signed char / int test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_c, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip132: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / unsigned int */
    if (verbose) printf("test for signed char / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip133;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_u);

	    result = proc(source1_c, source2_u);
	    if (expected_result != result) {
		printf("Failed signed char / unsigned int test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_c, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip133: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / uintptr_t */
    if (verbose) printf("test for signed char / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip134;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_ul);

	    result = proc(source1_c, source2_ul);
	    if (expected_result != result) {
		printf("Failed signed char / uintptr_t test, expected %d, got %d, for %d / %zu\n",
		       expected_result, result, source1_c, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip134: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / intptr_t */
    if (verbose) printf("test for signed char / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip135;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_l);

	    result = proc(source1_c, source2_l);
	    if (expected_result != result) {
		printf("Failed signed char / intptr_t test, expected %d, got %d, for %d / %zd\n",
		       expected_result, result, source1_c, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip135: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / float */
    if (verbose) printf("test for signed char / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_c / (double)source2_f));
	    signed char expected_result;
	    signed char result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip136;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_f);

	    result = proc(source1_c, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed signed char / float test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_c, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip136: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "c/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       signed char a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    signed char (*proc)(signed char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for signed char / double */
    if (verbose) printf("test for signed char / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("signed char proc(signed char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (signed char (*)(signed char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1c_vals)/sizeof(src1c_vals[0]) ; i++) {
        signed char source1_c = src1c_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    signed char expected_result;
	    signed char result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip137;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (signed char) (source1_c / source2_d);

	    result = proc(source1_c, source2_d);
	    if (expected_result != result) {
		printf("Failed signed char / double test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_c, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip137: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_uc_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / signed char */
    if (verbose) printf("test for unsigned char / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip138;}
	    expect_int = (unsigned int) (source1_uc / source2_c);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / signed char test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_uc, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip138: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / unsigned char */
    if (verbose) printf("test for unsigned char / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip139;}
	    expect_int = (unsigned int) (source1_uc / source2_uc);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / unsigned char test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_uc, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip139: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / short */
    if (verbose) printf("test for unsigned char / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip140;}
	    expect_int = (unsigned int) (source1_uc / source2_s);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / short test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_uc, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip140: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / unsigned short */
    if (verbose) printf("test for unsigned char / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip141;}
	    expect_int = (unsigned int) (source1_uc / source2_us);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / unsigned short test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_uc, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip141: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / int */
    if (verbose) printf("test for unsigned char / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip142;}
	    expect_int = (unsigned int) (source1_uc / source2_i);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / int test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_uc, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip142: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / unsigned int */
    if (verbose) printf("test for unsigned char / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip143;}
	    expect_int = (unsigned int) (source1_uc / source2_u);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / unsigned int test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_uc, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip143: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / uintptr_t */
    if (verbose) printf("test for unsigned char / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip144;}
	    expect_int = (unsigned int) (source1_uc / source2_ul);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / uintptr_t test, expected %u, got %u, for %u / %zu\n",
		       expected_result, result, source1_uc, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip144: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / intptr_t */
    if (verbose) printf("test for unsigned char / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip145;}
	    expect_int = (unsigned int) (source1_uc / source2_l);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / intptr_t test, expected %u, got %u, for %u / %zd\n",
		       expected_result, result, source1_uc, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip145: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / float */
    if (verbose) printf("test for unsigned char / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_uc / (double)source2_f));
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip146;}
	    expect_int = (unsigned int) (source1_uc / source2_f);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned char / float test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_uc, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip146: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "uc/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned char a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    unsigned char (*proc)(unsigned char a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned char / double */
    if (verbose) printf("test for unsigned char / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned char proc(unsigned char p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned char (*)(unsigned char, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1uc_vals)/sizeof(src1uc_vals[0]) ; i++) {
        unsigned char source1_uc = src1uc_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned int expect_int;
	    unsigned char expected_result;
	    unsigned char result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip147;}
	    expect_int = (unsigned int) (source1_uc / source2_d);
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned char) expect_int;

	    result = proc(source1_uc, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned char) 0xff) || (expected_result == (unsigned char) 0x80)) continue;
	if (expected_result != result) {
		printf("Failed unsigned char / double test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_uc, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip147: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_s_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / signed char */
    if (verbose) printf("test for short / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip148;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_c);

	    result = proc(source1_s, source2_c);
	    if (expected_result != result) {
		printf("Failed short / signed char test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_s, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip148: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / unsigned char */
    if (verbose) printf("test for short / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip149;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_uc);

	    result = proc(source1_s, source2_uc);
	    if (expected_result != result) {
		printf("Failed short / unsigned char test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_s, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip149: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / short */
    if (verbose) printf("test for short / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip150;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_s);

	    result = proc(source1_s, source2_s);
	    if (expected_result != result) {
		printf("Failed short / short test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_s, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip150: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / unsigned short */
    if (verbose) printf("test for short / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip151;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_us);

	    result = proc(source1_s, source2_us);
	    if (expected_result != result) {
		printf("Failed short / unsigned short test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_s, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip151: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / int */
    if (verbose) printf("test for short / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip152;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_i);

	    result = proc(source1_s, source2_i);
	    if (expected_result != result) {
		printf("Failed short / int test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_s, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip152: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / unsigned int */
    if (verbose) printf("test for short / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip153;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_u);

	    result = proc(source1_s, source2_u);
	    if (expected_result != result) {
		printf("Failed short / unsigned int test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_s, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip153: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / uintptr_t */
    if (verbose) printf("test for short / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip154;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_ul);

	    result = proc(source1_s, source2_ul);
	    if (expected_result != result) {
		printf("Failed short / uintptr_t test, expected %d, got %d, for %d / %zu\n",
		       expected_result, result, source1_s, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip154: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / intptr_t */
    if (verbose) printf("test for short / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip155;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_l);

	    result = proc(source1_s, source2_l);
	    if (expected_result != result) {
		printf("Failed short / intptr_t test, expected %d, got %d, for %d / %zd\n",
		       expected_result, result, source1_s, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip155: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / float */
    if (verbose) printf("test for short / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_s / (double)source2_f));
	    short expected_result;
	    short result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip156;}
	if ((source1_s/source2_f) < (-32768) || ((source1_s/source2_f) > 32767)){if (verbose) {printf("+");fflush(stdout);} goto skip156;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_f);

	    result = proc(source1_s, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed short / float test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_s, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip156: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "s/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       short a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    short (*proc)(short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for short / double */
    if (verbose) printf("test for short / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("short proc(short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (short (*)(short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1s_vals)/sizeof(src1s_vals[0]) ; i++) {
        short source1_s = src1s_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    short expected_result;
	    short result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip157;}
	if ((source1_s/source2_d) < (-32768) || ((source1_s/source2_d) > 32767)){if (verbose) {printf("+");fflush(stdout);} goto skip157;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (short) (source1_s / source2_d);

	    result = proc(source1_s, source2_d);
	    if (expected_result != result) {
		printf("Failed short / double test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_s, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip157: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_us_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / signed char */
    if (verbose) printf("test for unsigned short / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip158;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_c);

	    result = proc(source1_us, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / signed char test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_us, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip158: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / unsigned char */
    if (verbose) printf("test for unsigned short / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip159;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_uc);

	    result = proc(source1_us, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / unsigned char test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_us, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip159: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / short */
    if (verbose) printf("test for unsigned short / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip160;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_s);

	    result = proc(source1_us, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / short test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_us, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip160: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / unsigned short */
    if (verbose) printf("test for unsigned short / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip161;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_us);

	    result = proc(source1_us, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / unsigned short test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_us, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip161: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / int */
    if (verbose) printf("test for unsigned short / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip162;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_i);

	    result = proc(source1_us, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / int test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_us, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip162: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / unsigned int */
    if (verbose) printf("test for unsigned short / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip163;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_u);

	    result = proc(source1_us, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / unsigned int test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_us, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip163: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / uintptr_t */
    if (verbose) printf("test for unsigned short / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip164;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_ul);

	    result = proc(source1_us, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / uintptr_t test, expected %u, got %u, for %u / %zu\n",
		       expected_result, result, source1_us, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip164: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / intptr_t */
    if (verbose) printf("test for unsigned short / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip165;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_l);

	    result = proc(source1_us, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / intptr_t test, expected %u, got %u, for %u / %zd\n",
		       expected_result, result, source1_us, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip165: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / float */
    if (verbose) printf("test for unsigned short / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_us / (double)source2_f));
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip166;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_f);

	    result = proc(source1_us, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned short / float test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_us, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip166: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "us/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned short a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    unsigned short (*proc)(unsigned short a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned short / double */
    if (verbose) printf("test for unsigned short / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned short proc(unsigned short p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned short (*)(unsigned short, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1us_vals)/sizeof(src1us_vals[0]) ; i++) {
        unsigned short source1_us = src1us_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned short expected_result;
	    unsigned short result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip167;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned short) (source1_us / source2_d);

	    result = proc(source1_us, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned short) 0xffff) || (expected_result == (unsigned short) 0x8000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned short / double test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_us, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip167: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_i_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / signed char */
    if (verbose) printf("test for int / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip168;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_c);

	    result = proc(source1_i, source2_c);
	    if (expected_result != result) {
		printf("Failed int / signed char test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_i, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip168: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / unsigned char */
    if (verbose) printf("test for int / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip169;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_uc);

	    result = proc(source1_i, source2_uc);
	    if (expected_result != result) {
		printf("Failed int / unsigned char test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_i, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip169: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / short */
    if (verbose) printf("test for int / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip170;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_s);

	    result = proc(source1_i, source2_s);
	    if (expected_result != result) {
		printf("Failed int / short test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_i, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip170: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / unsigned short */
    if (verbose) printf("test for int / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip171;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_us);

	    result = proc(source1_i, source2_us);
	    if (expected_result != result) {
		printf("Failed int / unsigned short test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_i, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip171: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / int */
    if (verbose) printf("test for int / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip172;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_i);

	    result = proc(source1_i, source2_i);
	    if (expected_result != result) {
		printf("Failed int / int test, expected %d, got %d, for %d / %d\n",
		       expected_result, result, source1_i, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip172: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / unsigned int */
    if (verbose) printf("test for int / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip173;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_u);

	    result = proc(source1_i, source2_u);
	    if (expected_result != result) {
		printf("Failed int / unsigned int test, expected %d, got %d, for %d / %u\n",
		       expected_result, result, source1_i, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip173: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / uintptr_t */
    if (verbose) printf("test for int / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip174;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_ul);

	    result = proc(source1_i, source2_ul);
	    if (expected_result != result) {
		printf("Failed int / uintptr_t test, expected %d, got %d, for %d / %zu\n",
		       expected_result, result, source1_i, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip174: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / intptr_t */
    if (verbose) printf("test for int / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip175;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_l);

	    result = proc(source1_i, source2_l);
	    if (expected_result != result) {
		printf("Failed int / intptr_t test, expected %d, got %d, for %d / %zd\n",
		       expected_result, result, source1_i, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip175: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / float */
    if (verbose) printf("test for int / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_i / (double)source2_f));
	    int expected_result;
	    int result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip176;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_f);

	    result = proc(source1_i, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed int / float test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_i, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip176: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "i/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       int a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    int (*proc)(int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for int / double */
    if (verbose) printf("test for int / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("int proc(int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (int (*)(int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1i_vals)/sizeof(src1i_vals[0]) ; i++) {
        int source1_i = src1i_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    int expected_result;
	    int result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip177;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (int) (source1_i / source2_d);

	    result = proc(source1_i, source2_d);
	    if (expected_result != result) {
		printf("Failed int / double test, expected %d, got %d, for %d / %g\n",
		       expected_result, result, source1_i, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip177: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_u_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / signed char */
    if (verbose) printf("test for unsigned int / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip178;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_c);

	    result = proc(source1_u, source2_c);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / signed char test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_u, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip178: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / unsigned char */
    if (verbose) printf("test for unsigned int / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip179;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_uc);

	    result = proc(source1_u, source2_uc);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / unsigned char test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_u, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip179: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / short */
    if (verbose) printf("test for unsigned int / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip180;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_s);

	    result = proc(source1_u, source2_s);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / short test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_u, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip180: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / unsigned short */
    if (verbose) printf("test for unsigned int / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip181;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_us);

	    result = proc(source1_u, source2_us);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / unsigned short test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_u, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip181: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / int */
    if (verbose) printf("test for unsigned int / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip182;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_i);

	    result = proc(source1_u, source2_i);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / int test, expected %u, got %u, for %u / %d\n",
		       expected_result, result, source1_u, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip182: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / unsigned int */
    if (verbose) printf("test for unsigned int / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip183;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_u);

	    result = proc(source1_u, source2_u);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / unsigned int test, expected %u, got %u, for %u / %u\n",
		       expected_result, result, source1_u, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip183: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / uintptr_t */
    if (verbose) printf("test for unsigned int / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip184;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_ul);

	    result = proc(source1_u, source2_ul);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / uintptr_t test, expected %u, got %u, for %u / %zu\n",
		       expected_result, result, source1_u, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip184: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / intptr_t */
    if (verbose) printf("test for unsigned int / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip185;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_l);

	    result = proc(source1_u, source2_l);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / intptr_t test, expected %u, got %u, for %u / %zd\n",
		       expected_result, result, source1_u, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip185: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / float */
    if (verbose) printf("test for unsigned int / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_u / (double)source2_f));
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip186;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_f);

	    result = proc(source1_u, source2_f);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed unsigned int / float test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_u, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip186: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "u/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned int a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    unsigned int (*proc)(unsigned int a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for unsigned int / double */
    if (verbose) printf("test for unsigned int / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned int proc(unsigned int p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (unsigned int (*)(unsigned int, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1u_vals)/sizeof(src1u_vals[0]) ; i++) {
        unsigned int source1_u = src1u_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    unsigned int expected_result;
	    unsigned int result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip187;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (unsigned int) (source1_u / source2_d);

	    result = proc(source1_u, source2_d);
	    if ((expected_result == 0) || (expected_result == (unsigned int) 0xffffffff) || (expected_result == (unsigned int) 0x80000000)) continue;
	if (expected_result != result) {
		printf("Failed unsigned int / double test, expected %u, got %u, for %u / %g\n",
		       expected_result, result, source1_u, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip187: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_ul_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / signed char */
    if (verbose) printf("test for uintptr_t / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip188;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_c);

	    result = proc(source1_ul, source2_c);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / signed char test, expected %zu, got %zu, for %zu / %d\n",
		       expected_result, result, source1_ul, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip188: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / unsigned char */
    if (verbose) printf("test for uintptr_t / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip189;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_uc);

	    result = proc(source1_ul, source2_uc);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / unsigned char test, expected %zu, got %zu, for %zu / %u\n",
		       expected_result, result, source1_ul, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip189: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / short */
    if (verbose) printf("test for uintptr_t / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip190;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_s);

	    result = proc(source1_ul, source2_s);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / short test, expected %zu, got %zu, for %zu / %d\n",
		       expected_result, result, source1_ul, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip190: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / unsigned short */
    if (verbose) printf("test for uintptr_t / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip191;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_us);

	    result = proc(source1_ul, source2_us);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / unsigned short test, expected %zu, got %zu, for %zu / %u\n",
		       expected_result, result, source1_ul, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip191: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / int */
    if (verbose) printf("test for uintptr_t / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip192;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_i);

	    result = proc(source1_ul, source2_i);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / int test, expected %zu, got %zu, for %zu / %d\n",
		       expected_result, result, source1_ul, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip192: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / unsigned int */
    if (verbose) printf("test for uintptr_t / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip193;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_u);

	    result = proc(source1_ul, source2_u);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / unsigned int test, expected %zu, got %zu, for %zu / %u\n",
		       expected_result, result, source1_ul, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip193: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / uintptr_t */
    if (verbose) printf("test for uintptr_t / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip194;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_ul);

	    result = proc(source1_ul, source2_ul);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / uintptr_t test, expected %zu, got %zu, for %zu / %zu\n",
		       expected_result, result, source1_ul, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip194: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / intptr_t */
    if (verbose) printf("test for uintptr_t / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip195;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_l);

	    result = proc(source1_ul, source2_l);
	    if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / intptr_t test, expected %zu, got %zu, for %zu / %zd\n",
		       expected_result, result, source1_ul, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip195: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / float */
    if (verbose) printf("test for uintptr_t / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_ul / (double)source2_f));
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip196;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_f);

	    result = proc(source1_ul, source2_f);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed uintptr_t / float test, expected %zu, got %zu, for %zu / %g\n",
		       expected_result, result, source1_ul, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip196: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "ul/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       unsigned long a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    uintptr_t (*proc)(uintptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for uintptr_t / double */
    if (verbose) printf("test for uintptr_t / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("unsigned long proc(unsigned long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (uintptr_t (*)(uintptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1ul_vals)/sizeof(src1ul_vals[0]) ; i++) {
        uintptr_t source1_ul = src1ul_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    uintptr_t expected_result;
	    uintptr_t result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip197;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (uintptr_t) (source1_ul / source2_d);

	    result = proc(source1_ul, source2_d);
	    if (source1_ul > ((int64_t)11<<52)) continue;
 	if ((expected_result == 0) || (expected_result == (uintptr_t) 0xffffffffffffffff) || (expected_result == (uintptr_t) 0x8000000000000000)) continue;
	if (expected_result != result) {
		printf("Failed uintptr_t / double test, expected %zu, got %zu, for %zu / %g\n",
		       expected_result, result, source1_ul, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip197: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_l_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / signed char */
    if (verbose) printf("test for intptr_t / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip198;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_c);

	    result = proc(source1_l, source2_c);
	    if (expected_result != result) {
		printf("Failed intptr_t / signed char test, expected %zd, got %zd, for %zd / %d\n",
		       expected_result, result, source1_l, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip198: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / unsigned char */
    if (verbose) printf("test for intptr_t / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip199;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_uc);

	    result = proc(source1_l, source2_uc);
	    if (expected_result != result) {
		printf("Failed intptr_t / unsigned char test, expected %zd, got %zd, for %zd / %u\n",
		       expected_result, result, source1_l, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip199: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / short */
    if (verbose) printf("test for intptr_t / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip200;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_s);

	    result = proc(source1_l, source2_s);
	    if (expected_result != result) {
		printf("Failed intptr_t / short test, expected %zd, got %zd, for %zd / %d\n",
		       expected_result, result, source1_l, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip200: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / unsigned short */
    if (verbose) printf("test for intptr_t / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip201;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_us);

	    result = proc(source1_l, source2_us);
	    if (expected_result != result) {
		printf("Failed intptr_t / unsigned short test, expected %zd, got %zd, for %zd / %u\n",
		       expected_result, result, source1_l, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip201: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / int */
    if (verbose) printf("test for intptr_t / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip202;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_i);

	    result = proc(source1_l, source2_i);
	    if (expected_result != result) {
		printf("Failed intptr_t / int test, expected %zd, got %zd, for %zd / %d\n",
		       expected_result, result, source1_l, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip202: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / unsigned int */
    if (verbose) printf("test for intptr_t / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip203;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_u);

	    result = proc(source1_l, source2_u);
	    if (expected_result != result) {
		printf("Failed intptr_t / unsigned int test, expected %zd, got %zd, for %zd / %u\n",
		       expected_result, result, source1_l, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip203: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / uintptr_t */
    if (verbose) printf("test for intptr_t / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip204;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_ul);

	    result = proc(source1_l, source2_ul);
	    if (expected_result != result) {
		printf("Failed intptr_t / uintptr_t test, expected %zd, got %zd, for %zd / %zu\n",
		       expected_result, result, source1_l, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip204: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / intptr_t */
    if (verbose) printf("test for intptr_t / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip205;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_l);

	    result = proc(source1_l, source2_l);
	    if (expected_result != result) {
		printf("Failed intptr_t / intptr_t test, expected %zd, got %zd, for %zd / %zd\n",
		       expected_result, result, source1_l, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip205: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / float */
    if (verbose) printf("test for intptr_t / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_l / (double)source2_f));
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip206;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_f);

	    result = proc(source1_l, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed intptr_t / float test, expected %zd, got %zd, for %zd / %g\n",
		       expected_result, result, source1_l, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip206: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "l/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       long a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    intptr_t (*proc)(intptr_t a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for intptr_t / double */
    if (verbose) printf("test for intptr_t / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("long proc(long p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (intptr_t (*)(intptr_t, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1l_vals)/sizeof(src1l_vals[0]) ; i++) {
        intptr_t source1_l = src1l_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    intptr_t expected_result;
	    intptr_t result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip207;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (intptr_t) (source1_l / source2_d);

	    result = proc(source1_l, source2_d);
	    if (expected_result != result) {
		printf("Failed intptr_t / double test, expected %zd, got %zd, for %zd / %g\n",
		       expected_result, result, source1_l, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip207: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_f_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / signed char */
    if (verbose) printf("test for float / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_c));
	    float expected_result;
	    float result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip208;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_c);

	    result = proc(source1_f, source2_c);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / signed char test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_f, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip208: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / unsigned char */
    if (verbose) printf("test for float / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_uc));
	    float expected_result;
	    float result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip209;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_uc);

	    result = proc(source1_f, source2_uc);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / unsigned char test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_f, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip209: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / short */
    if (verbose) printf("test for float / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_s));
	    float expected_result;
	    float result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip210;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_s);

	    result = proc(source1_f, source2_s);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / short test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_f, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip210: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / unsigned short */
    if (verbose) printf("test for float / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_us));
	    float expected_result;
	    float result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip211;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_us);

	    result = proc(source1_f, source2_us);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / unsigned short test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_f, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip211: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / int */
    if (verbose) printf("test for float / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_i));
	    float expected_result;
	    float result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip212;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_i);

	    result = proc(source1_f, source2_i);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / int test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_f, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip212: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / unsigned int */
    if (verbose) printf("test for float / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_u));
	    float expected_result;
	    float result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip213;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_u);

	    result = proc(source1_f, source2_u);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / unsigned int test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_f, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip213: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / uintptr_t */
    if (verbose) printf("test for float / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_ul));
	    float expected_result;
	    float result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip214;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_ul);

	    result = proc(source1_f, source2_ul);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / uintptr_t test, expected %g, got %g, for %g / %zu\n",
		       expected_result, result, source1_f, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip214: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / intptr_t */
    if (verbose) printf("test for float / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_l));
	    float expected_result;
	    float result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip215;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_l);

	    result = proc(source1_f, source2_l);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / intptr_t test, expected %g, got %g, for %g / %zd\n",
		       expected_result, result, source1_f, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip215: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / float */
    if (verbose) printf("test for float / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_f));
	    float expected_result;
	    float result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip216;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_f);

	    result = proc(source1_f, source2_f);
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / float test, expected %g, got %g, for %g / %g\n",
		       expected_result, result, source1_f, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip216: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "f/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       float a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    float (*proc)(float a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for float / double */
    if (verbose) printf("test for float / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("float proc(float p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (float (*)(float, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1f_vals)/sizeof(src1f_vals[0]) ; i++) {
        float source1_f = src1f_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    double range = 0.000001 * (fabs((double)source1_f / (double)source2_d));
	    float expected_result;
	    float result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip217;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (float) (source1_f / source2_d);

	    result = proc(source1_f, source2_d);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed float / double test, expected %g, got %g, for %g / %g\n",
		       expected_result, result, source1_f, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip217: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}
void div_d_tests()
{
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/c") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       signed char b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, signed char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / signed char */
    if (verbose) printf("test for double / signed char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, signed char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, signed char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2c_vals)/sizeof(src2c_vals[0]) ; j++) {
            signed char source2_c = src2c_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_c == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip218;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_c);

	    result = proc(source1_d, source2_c);
	    if (expected_result != result) {
		printf("Failed double / signed char test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_d, source2_c);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip218: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/uc") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned char b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, unsigned char b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / unsigned char */
    if (verbose) printf("test for double / unsigned char");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned char p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned char))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2uc_vals)/sizeof(src2uc_vals[0]) ; j++) {
            unsigned char source2_uc = src2uc_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_uc == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip219;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_uc);

	    result = proc(source1_d, source2_uc);
	    if (expected_result != result) {
		printf("Failed double / unsigned char test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_d, source2_uc);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip219: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/s") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       short b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / short */
    if (verbose) printf("test for double / short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2s_vals)/sizeof(src2s_vals[0]) ; j++) {
            short source2_s = src2s_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_s == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip220;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_s);

	    result = proc(source1_d, source2_s);
	    if (expected_result != result) {
		printf("Failed double / short test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_d, source2_s);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip220: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/us") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned short b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, unsigned short b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / unsigned short */
    if (verbose) printf("test for double / unsigned short");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned short p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned short))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2us_vals)/sizeof(src2us_vals[0]) ; j++) {
            unsigned short source2_us = src2us_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_us == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip221;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_us);

	    result = proc(source1_d, source2_us);
	    if (expected_result != result) {
		printf("Failed double / unsigned short test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_d, source2_us);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip221: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/i") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       int b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / int */
    if (verbose) printf("test for double / int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2i_vals)/sizeof(src2i_vals[0]) ; j++) {
            int source2_i = src2i_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_i == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip222;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_i);

	    result = proc(source1_d, source2_i);
	    if (expected_result != result) {
		printf("Failed double / int test, expected %g, got %g, for %g / %d\n",
		       expected_result, result, source1_d, source2_i);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip222: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/u") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned int b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, unsigned int b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / unsigned int */
    if (verbose) printf("test for double / unsigned int");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned int p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, unsigned int))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2u_vals)/sizeof(src2u_vals[0]) ; j++) {
            unsigned int source2_u = src2u_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_u == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip223;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_u);

	    result = proc(source1_d, source2_u);
	    if (expected_result != result) {
		printf("Failed double / unsigned int test, expected %g, got %g, for %g / %u\n",
		       expected_result, result, source1_d, source2_u);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip223: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/ul") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       unsigned long b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, uintptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / uintptr_t */
    if (verbose) printf("test for double / uintptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, unsigned long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, uintptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2ul_vals)/sizeof(src2ul_vals[0]) ; j++) {
            uintptr_t source2_ul = src2ul_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_ul == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip224;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_ul);

	    result = proc(source1_d, source2_ul);
	    if (expected_result != result) {
		printf("Failed double / uintptr_t test, expected %g, got %g, for %g / %zu\n",
		       expected_result, result, source1_d, source2_ul);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip224: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/l") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       long b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, intptr_t b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / intptr_t */
    if (verbose) printf("test for double / intptr_t");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, long p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, intptr_t))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2l_vals)/sizeof(src2l_vals[0]) ; j++) {
            intptr_t source2_l = src2l_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_l == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip225;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_l);

	    result = proc(source1_d, source2_l);
	    if (expected_result != result) {
		printf("Failed double / intptr_t test, expected %g, got %g, for %g / %zd\n",
		       expected_result, result, source1_d, source2_l);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip225: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/f") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       float b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, float b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / float */
    if (verbose) printf("test for double / float");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, float p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, float))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2f_vals)/sizeof(src2f_vals[0]) ; j++) {
            float source2_f = src2f_vals[j];
	    double range = 0.000001 * (fabs((double)source1_d / (double)source2_f));
	    double expected_result;
	    double result;

	    if (source2_f == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip226;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_f);

	    result = proc(source1_d, source2_f);
	    range += 1.0;
	    if ((result > (expected_result + range)) || (result < (expected_result - range))) {
		printf("Failed double / float test, expected %g, got %g, for %g / %g\n",
		       expected_result, result, source1_d, source2_f);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip226: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
  if ((only_run_test == NULL) || 
      (strcmp(only_run_test, "d/d") == 0)) {
     int i, j;
     static char code[] = "{\n\
       double a = p1;\n\
       double b = p2;\n\
       return a / b;\n\
     }";

    double (*proc)(double a, double b);
    cod_parse_context context = new_cod_parse_context();
    int dumped = 0;

    cod_code gen_code;

    /* test for double / double */
    if (verbose) printf("test for double / double");

    cod_assoc_externs(context, externs);
    cod_parse_for_context(extern_string, context);

    cod_subroutine_declaration("double proc(double p1, double p2)",
			       context);
    gen_code = cod_code_gen(code, context);
    proc = (double (*)(double, double))(intptr_t)gen_code->func;


    for (i=0 ; i < sizeof(src1d_vals)/sizeof(src1d_vals[0]) ; i++) {
        double source1_d = src1d_vals[i];
        for (j=0 ; j < sizeof(src2d_vals)/sizeof(src2d_vals[0]) ; j++) {
            double source2_d = src2d_vals[j];
	    
	    double expected_result;
	    double result;

	    if (source2_d == 0) {if (verbose) {printf("+");fflush(stdout);} goto skip227;}
	    if (verbose) {printf(".");fflush(stdout);}

	    expected_result = (double) (source1_d / source2_d);

	    result = proc(source1_d, source2_d);
	    if (expected_result != result) {
		printf("Failed double / double test, expected %g, got %g, for %g / %g\n",
		       expected_result, result, source1_d, source2_d);
		if (dumped == 0) cod_dump(gen_code);
		failed++;
		dumped++;
	    }
skip227: ;
	}
    }
    if (verbose) printf(" done\n");
    cod_free_parse_context(context);
    cod_code_free(gen_code);
  }
}

int
main(int argc, char **argv)
{
    int i = 1;

    initialize_values();

    while (i < argc) {
	if (strcmp(argv[i], "-v") == 0) {
	    verbose++;
	} else {
	    printf("Only running test \"%s\"\n", argv[i]);
	    only_run_test = argv[i];
	}
	i++;
    }

    
    mod_c_tests();

    mod_uc_tests();

    mod_s_tests();

    mod_us_tests();

    mod_i_tests();

    mod_u_tests();

    mod_ul_tests();

    mod_l_tests();

    and_c_tests();

    and_uc_tests();

    and_s_tests();

    and_us_tests();

    and_i_tests();

    and_u_tests();

    and_ul_tests();

    and_l_tests();

    or_c_tests();

    or_uc_tests();

    or_s_tests();

    or_us_tests();

    or_i_tests();

    or_u_tests();

    or_ul_tests();

    or_l_tests();

    not_c_tests();

    not_uc_tests();

    not_s_tests();

    not_us_tests();

    not_i_tests();

    not_u_tests();

    not_ul_tests();

    not_l_tests();

    lsh_c_tests();

    lsh_uc_tests();

    lsh_s_tests();

    lsh_us_tests();

    lsh_i_tests();

    lsh_u_tests();

    lsh_ul_tests();

    lsh_l_tests();

    rsh_c_tests();

    rsh_uc_tests();

    rsh_s_tests();

    rsh_us_tests();

    rsh_i_tests();

    rsh_u_tests();

    rsh_ul_tests();

    rsh_l_tests();

    add_c_tests();

    add_uc_tests();

    add_s_tests();

    add_us_tests();

    add_i_tests();

    add_u_tests();

    add_ul_tests();

    add_l_tests();

    add_f_tests();

    add_d_tests();

    sub_c_tests();

    sub_uc_tests();

    sub_s_tests();

    sub_us_tests();

    sub_i_tests();

    sub_u_tests();

    sub_ul_tests();

    sub_l_tests();

    sub_f_tests();

    sub_d_tests();

    mult_c_tests();

    mult_uc_tests();

    mult_s_tests();

    mult_us_tests();

    mult_i_tests();

    mult_u_tests();

    mult_ul_tests();

    mult_l_tests();

    mult_f_tests();

    mult_d_tests();

    div_c_tests();

    div_uc_tests();

    div_s_tests();

    div_us_tests();

    div_i_tests();

    div_u_tests();

    div_ul_tests();

    div_l_tests();

    div_f_tests();

    div_d_tests();

    return failed;
}
